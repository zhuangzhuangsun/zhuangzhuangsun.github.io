{"meta":{"title":"韭菜熟了","subtitle":null,"description":null,"author":"mike","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"phash","slug":"phash","date":"2019-04-23T07:43:45.000Z","updated":"2019-04-23T07:45:16.799Z","comments":false,"path":"2019/04/23/phash/","link":"","permalink":"http://yoursite.com/2019/04/23/phash/","excerpt":"","text":"phash算法pHash的工作过程如下： （1）缩小尺寸：pHash以小图片开始，但图片大于8 8，32 32是最好的。这样做的目的是简化了DCT的计算，而不是减小频率。 （2）简化色彩：将图片转化成灰度图像，进一步简化计算量。 （3）计算DCT：计算图片的DCT变换，得到32 * 32的DCT系数矩阵。 （4）缩小DCT：虽然DCT的结果是32 32大小的矩阵，但我们只要保留左上角的8 8的矩阵，这部分呈现了图片中的最低频率。 （5）计算平均值：如同均值哈希一样，计算DCT的均值。 （6）计算hash值：这是最主要的一步，根据8 * 8的DCT矩阵，设置0或1的64位的hash值，大于等于DCT均值的设为”1”，小于DCT均值的设为“0”。组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。 代码地址：https://github.com/JohannesBuchner/imagehash 代码示例 123456789import imagebashfrom PIL import Imagehash=imagehash.phash(Image.open('world1.png'))# hash=imagehash.average_hash(Image.open('world1.png')) #均值hash# hash=imagehash.dhash(Image.open('world1.png')) #dhash# hash=imagehash.whash(Image.open('world1.png')) #whashotherhash=imagehash.phash(Image.open('world2.png'))print(hash-otherhash)out: 15","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"dhash","slug":"dhash","permalink":"http://yoursite.com/tags/dhash/"}]},{"title":"python的类成员方法","slug":"python的类成员方法","date":"2019-04-20T12:08:13.000Z","updated":"2019-04-20T12:54:04.035Z","comments":false,"path":"2019/04/20/python的类成员方法/","link":"","permalink":"http://yoursite.com/2019/04/20/python的类成员方法/","excerpt":"原作者：haozlee来源：CSDN原文题目：Python 实例方法、类方法和静态方法链接：https://blog.csdn.net/lihao21/article/details/79762681版权声明：本文为博主原创文章，转载请附上博文链接！","text":"原作者：haozlee来源：CSDN原文题目：Python 实例方法、类方法和静态方法链接：https://blog.csdn.net/lihao21/article/details/79762681版权声明：本文为博主原创文章，转载请附上博文链接！Python 的类成员方法分为实例方法，类方法和静态方法。 实例方法实例方法用得最多，也最常见。1234567891011121314151617class Kls(object): def __init__(self, data): self.data = data def printd(self): print(self.data)ik1 = Kls('leo')ik2 = Kls('lee')ik1.printd()ik2.printd()输出：leo lee 上述例子中，printd为一个实例方法。实例方法第一个参数为self，当使用ik1.printd()调用实例方法时，实例ik1会传递给self参数，这样self参数就可以引用当前正在调用实例方法的实例。利用实例方法的这个特性，上述代码正确输出了两个实例的成员数据 类方法类方法采用装饰器@classmethod来定义。1234567891011121314151617181920class Kls(object): num_inst = 0 def __init__(self): Kls.num_inst = Kls.num_inst + 1 @classmethod def get_no_of_instance(cls): return cls.num_instik1 = Kls()ik2 = Kls()print ik1.get_no_of_instance()print Kls.get_no_of_instance()输出为：22 上述例子中，我们需要统计类Kls实例的个数，因此定义了一个类变量num_inst来存放实例个数。通过装饰器@classmethod的使用，方法get_no_of_instance被定义成一个类方法。在调用类方法时，Python 会将类（class Kls）传递给cls，这样在get_no_of_instance内部就可以引用类变量num_inst。由于在调用类方法时，只需要将类型本身传递给类方法，因此，既可以通过类也可以通过实例来调用类方法。 静态方法在开发中，我们常常需要定义一些方法，这些方法跟类有关，但在实现时并不需要引用类或者实例，例如，设置环境变量，修改另一个类的变量，等。这个时候，我们可以使用静态方法。Python 使用装饰器@staticmethod来定义一个静态方法。123456789101112131415161718192021222324252627IND = 'ON'class Kls(object): def __init__(self, data): self.data = data @staticmethod def checkind(): return IND == 'ON' def do_reset(self): if self.checkind(): print('Reset done for: %s' % self.data) def set_db(self): if self.checkind(): print('DB connection made for: %s' % self.data)ik1 = Kls(24)ik1.do_reset()ik1.set_db()输出为：Reset done for: 24 DB connection made for: 24 在代码中，我们定义了一个全局变量IND，由于IND跟类Kls相关，所以我们将方法checkind放置在类Kls中定义。方法checkind只需检查IND的值，而不需要引用类或者实例，因此，我们将方法checkind定义为静态方法。对于静态方法，Python 并不需要传递类或者实例，因此，既可以使用类也可以使用实例来调用静态方法。 实例方法，类方法与静态方法的区别123456789101112131415161718192021222324252627282930313233343536373839404142class Kls(object): def foo(self, x): print('executing foo(%s,%s)' % (self, x)) @classmethod # Python 使用装饰器@staticmethod来定义一个类方法。 def class_foo(cls,x): print('executing class_foo(%s,%s)' % (cls,x)) @staticmethod # Python 使用装饰器@staticmethod来定义一个静态方法。 def static_foo(x): print('executing static_foo(%s)' % x)ik = Kls()# 实例方法ik.foo(1)print(ik.foo)print('==========================================')# 类方法ik.class_foo(1)Kls.class_foo(1)print(ik.class_foo)print('==========================================')# 静态方法ik.static_foo(1)Kls.static_foo('hi')print(ik.static_foo)输出为：executing foo(&lt;__main__.Kls object at 0x0551E190&gt;,1)&lt;bound method Kls.foo of &lt;__main__.Kls object at 0x0551E190&gt;&gt;==========================================executing class_foo(&lt;class '__main__.Kls'&gt;,1)executing class_foo(&lt;class '__main__.Kls'&gt;,1)&lt;bound method type.class_foo of &lt;class '__main__.Kls'&gt;&gt;==========================================executing static_foo(1)executing static_foo(hi)&lt;function static_foo at 0x055238B0&gt; 对于实例方法，调用时会把实例ik作为第一个参数传递给self参数。因此，调用ik.foo(1)时输出了实例ik的地址。 对于类方法，调用时会把类Kls作为第一个参数传递给cls参数。因此，调用ik.class_foo(1)时输出了Kls类型信息。前面提到，可以通过类也可以通过实例来调用类方法，在上述代码中，我们再一次进行了验证。 对于静态方法，调用时并不需要传递类或者实例。其实，静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"dhash","slug":"感知哈希算法","date":"2019-04-20T12:07:44.000Z","updated":"2019-04-23T07:44:26.723Z","comments":false,"path":"2019/04/20/感知哈希算法/","link":"","permalink":"http://yoursite.com/2019/04/20/感知哈希算法/","excerpt":"来源：简书 原作者：AmazingBillions链接：https://www.jianshu.com/p/193f0089b7a2","text":"来源：简书 原作者：AmazingBillions链接：https://www.jianshu.com/p/193f0089b7a2感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个“指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。达到图片比较目的且利用信息指纹比较。 感知哈希算法目前有： aHash：平均值哈希，速度快，但准确率较低。pHash：感知哈希，准确率高，但速度较慢。dHash：差异值哈希，速度快，且准确率高。 差异哈希算法（dHash）step1. 缩放图片如果我们要计算上图的dHash值，第一步是把它缩放到足够小。如果我们要计算上图的dHash值，第一步是把它缩放到足够小。为什么需要缩放呢？因为原图的分辨率一般都非常高。一张 200200 的图片，就有整整4万个像素点，每一个像素点都保存着一个RGB值，4万个RGB，是相当庞大的信息量，非常多的细节需要处理。因此，我们需要把图片缩放到非常小，隐藏它的细节部分，只见森林，不见树木。建议缩放为98，虽然可以缩放为任意大小，但是这个值是相对合理的。而且宽度为9，有利于我们转换为hash值。Step2. 灰度化dHash全名为差异值hash，通过计算相邻像素之间的颜色强度差异得出。我们缩放后的图片，细节已经被隐藏，信息量已经变少。但是还不够，因为它是彩色的，由RGB值组成。白色表示为（255,255,255）,黑色表示为（0,0,0），值越大颜色越亮，越小则越暗。每种颜色都由3个数值组成，也就是红、绿、蓝的值 。如果直接使用RGB值对比颜色强度差异，相当复杂，因此我们转化为灰度值——只由一个0到255的整数表示灰度。这样的话就将三维的比较简化为了一维比较。Step3. 差异计算差异值是通过计算每行相邻像素的强度对比得出的。我们的图片为9*8的分辨率，那么就有8行，每行9个像素。差异值是每行分别计算的，也就是第二行的第一个像素不会与第一行的任何像素比较。 如果前一个像素的颜色强度大于第二个像素，那么差异值就设置为True（也就是1），如果不大于第二个像素，就设置为False（也就是0）。 Step4. 转换为hash值我们将差异值数组中每一个值看做一个bit，每8个bit组成为一个16进制值，将16进制值连接起来转换为字符串，就得出了最后的dHash值。 Step5.计算汉明距离汉明距离这个概念不止运用于图片对比领域，也被使用于众多领域，具体的介绍可以参见Wikipedia。汉明距离表示将A修改成为B，需要多少个步骤。比如字符串“abc”与“ab3”，汉明距离为1，因为只需要修改“c”为“3”即可。dHash中的汉明距离是通过计算差异值的修改位数。我们的差异值是用0、1表示的，可以看做二进制。二进制0110与1111的汉明距离为2。我们将两张图片的dHash值转换为二进制difference，并取异或。计算异或结果的“1”的位数，也就是不相同的位数，这就是汉明距离 如果传入的参数不是两张图的dHash值，而是直接比较两张图片，那么不需要生成dHash值，直接用Step3中的difference数组，统计不相同的位数，就是汉明距离。一般来说，汉明距离小于5，基本就是同一张图片。大家可以根据自己的实际情况，判断汉明距离临界值为多少。 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class DHash(object): @staticmethod def calculate_hash(image): \"\"\" 计算图片的dHash值 :param image: PIL.Image :return: dHash值,string类型 \"\"\" difference = DHash.__difference(image) # 转化为16进制(每个差值为一个bit,每8bit转为一个16进制) decimal_value = 0 hash_string = \"\" for index, value in enumerate(difference): if value: # value为0, 不用计算, 程序优化 decimal_value += value * (2 ** (index % 8)) if index % 8 == 7: # 每8位的结束 hash_string += str(hex(decimal_value)[2:].rjust(2, \"0\")) # 不足2位以0填充。0xf=&gt;0x0f decimal_value = 0 return hash_string @staticmethod def hamming_distance(first, second): \"\"\" 计算两张图片的汉明距离(基于dHash算法) :param first: Image或者dHash值(str) :param second: Image或者dHash值(str) :return: hamming distance. 值越大,说明两张图片差别越大,反之,则说明越相似 \"\"\" # A. dHash值计算汉明距离 if isinstance(first, str): return DHash.__hamming_distance_with_hash(first, second) # B. image计算汉明距离 hamming_distance = 0 image1_difference = DHash.__difference(first) image2_difference = DHash.__difference(second) for index, img1_pix in enumerate(image1_difference): img2_pix = image2_difference[index] if img1_pix != img2_pix: hamming_distance += 1 return hamming_distance @staticmethod def __difference(image): \"\"\" *Private method* 计算image的像素差值 :param image: PIL.Image :return: 差值数组。0、1组成 \"\"\" resize_width = 9 resize_height = 8 # 1. resize to (9,8) smaller_image = image.resize((resize_width, resize_height)) # 2. 灰度化 Grayscale grayscale_image = smaller_image.convert(\"L\") # 3. 比较相邻像素 pixels = list(grayscale_image.getdata()) difference = [] for row in range(resize_height): row_start_index = row * resize_width for col in range(resize_width - 1): left_pixel_index = row_start_index + col difference.append(pixels[left_pixel_index] &gt; pixels[left_pixel_index + 1]) return difference @staticmethod def __hamming_distance_with_hash(dhash1, dhash2): \"\"\" *Private method* 根据dHash值计算hamming distance :param dhash1: str :param dhash2: str :return: 汉明距离(int) \"\"\" difference = (int(dhash1, 16)) ^ (int(dhash2, 16)) return bin(difference).count(\"1\")","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"dhash","slug":"dhash","permalink":"http://yoursite.com/tags/dhash/"}]},{"title":"基于对象的编程风格","slug":"基于对象的编程风格","date":"2019-04-19T08:25:20.000Z","updated":"2019-04-21T14:53:30.622Z","comments":false,"path":"2019/04/19/基于对象的编程风格/","link":"","permalink":"http://yoursite.com/2019/04/19/基于对象的编程风格/","excerpt":"","text":"class 名称被视为一个类型(type)名称，如同int ,double一样。Class object的初始化做法有很多种。每个class都会提供一组操作函数，可以作用于其object上。这些操作函数包括具名函数，如size(),empty()，以及各种重载的运算符，如equality和assignment运算符。 实现一个Class12345678910111213class Stack&#123;public: bool push(const string&amp;); bool pop(string &amp;elem); bool peek(string &amp;elem); bool empty(); bool full(); int size()&#123;return _stack.size();&#125;private: vector&lt;string&gt; _stack;# 编程习惯，在data member之前加下划线_&#125;; 上面为class的声名。Public member可以在成员的任何地方被访问，而private member只能在member fuction或class friend内被访问。所有的member fuction都必须在class主体内进行声明，若在主体内定义则会被视为inline函数。在class主体外定义inline函数要在最前面指定关键字inline。 class member fuction定义为了分辨该函数属于哪一个class，在class主体外定义member fuction要在函数名前加类名和两个冒号，例如:123456789101112131415inline boolStack::empty()&#123; return _stack.empty();&#125;boolStack::pop(string &amp;elem)&#123; if(empty()) return false; elem=_stack.back(); _stack.pop_back(); return true;&#125; 构造函数(constructor)和析构函数(destructor)1234567891011121314151617181920212223242526class Triangular&#123;public: //一组重载的constructor Triangular(); //default constructors Triangular(int len); Triangular(int len,int beg_pos);private: ......&#125;;//构造函数的实现Triangular::Triangular()&#123; _length = 1; _beg_pos = 1; _next =0;&#125;Triangular::Triangular(int len,int bp)&#123; //_legth和_beg_pos必须&gt;=1 //最好不要相信‘用户永远是对的’这句话 _length = len&gt;0? len : 1; _beg_pos = bp&gt;0? bp : 1; _next =_beg_pos-1;&#125; 成员初始化列表Member initialization list主要用于将参数传给member class object的constructor。 定义一个包含string member的Triangular类 1234567891011121314151617class Triangular&#123;public: //...private: string _name; int _next, _length, _beg_pos;&#125;;//为了将_name的值传给string constructor，必须使用member initialization list完成初始化。Triangular::Triangular(int len,int bp) ：_name(\"Triangular\")&#123; _length = len&gt;0? len : 1; _beg_pos = bp&gt;0? bp : 1; _next =_beg_pos-1;&#125; deconstructordestructor的名称有严格规定：class名称加~前缀，没有返回值也没有任何参数。不可能被重载。 1234567891011121314class Matrix&#123;public: Matrix(int row, int col) :_row(row),_col(col) &#123; _pmat = new double[row*col] ;//注意此处未检查成功与否 &#125; ~Matrix() &#123; //进行资源的释放 delete[] _pmat; &#125;&#125;; 成员逐一初始化 默认情况下，当用某个class object来作为另一个object的初值时，default memberwise initialization会一次复制class data member。 在Triangular类中使用默认的成员逐一初始化会正确复制所有的data member，但是对Matrix类使用默认的成员逐一初始化则并不适当。 12345678Matrix mat(4,4);//constructor发生作用Matrix mat2 = mat ; //进行default memberwise initialization//在这里使用mat2//在这里mat2的destructor起作用// 在这里使用mat//mat的destructor起作用 default memberwise initialization将mat2的_pmat设置为mat的_pmat的值：1mat2._pmat = mat._pmat; 当mat2的destructor作用后，该空间便被释放，但是mat的_pmat仍指向该数组，这是非常严重的错误行为。 正确的方法是为其设计合适的copy constructor 123456789Matrix::Matrix(const Matrix &amp;rhs) :_row(rhs._row),_col(rhs._col) &#123; //对rhs._pmat所指的数组产生一份完全的复本 int elem_cnt = _row*_col; _pmat = new double(elem_cnt); for(int ix=0;ix&lt;elem_cnt;++ix) _pmat[ix]=rhs._pmat[ix]; &#125; mutable(可变)和const(不变)1int sum(const Triangular &amp;train) train为 const reference参数 编译器必须保证train在sum中不会被修改。为此class设计者必须在member fuction身上标注const来告诉编译器：此member function不会更改class object内容。 1234567891011121314151617class Triangular&#123;public: //const member function int length() const&#123;return _length&#125;; int beg_pos() const&#123;return _beg_pos&#125;; int elem(int pos) const; //non-const member function bool next(int &amp;val); void next_reset()&#123;_next=beg_pos-1&#125;;private: int _length; int _beg_pos; mutable int _next; //static data member static vector&lt;int&gt; _elems;&#125;; 上述程序将_next标示为mutable，表示改变_next的值，不能视为改变class object的状态，或者是不算是改变了class object的常量性(constness)。若一个函数改变了Triangular object的_next值，其仍然可以被标示为const，而不会报错。 this指针this指针在member function中用来指向其调用者(一个对象)。1234567891011Triangular&amp; Triangular::copy(const Triangular &amp;rhs)&#123; if(this != &amp;rhs) &#123; _length=rhs._length; _beg_pos=rhs._beg_pos; _next=_rhs._beg_pos-1; &#125; return *this;&#125; 静态类成员static data member用来表示唯一的 可共享的member。它可以在同一类的所有对象中被访问。对class 来说，static data member只有唯一的一份实体。因此我们必须在程序代码中提供其清楚的定义。1vector&lt;int&gt; Triangular::_elems; static member fuction(静态成员函数在成员函数前面加上static，可以让该函数在与任何对象都无瓜葛的情形下被调用。例如:12if(Triangular::is_elem(8)) ..... 运算符重载(打造一个Iterator Class)为了说明如何对class进行运算符重载操作，我们来实现一个iterator class。我们需要提供以下操作方式。 123456789Triangular train(1,8);Triangular::iterator it = train.begin(); end_it=train.end();while(it!=end_it)&#123; cout&lt;&lt;*it&lt;&lt;' '; ++it;&#125; 实现Triangular_iterator类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Triangular_iterator&#123;public://为了不在每次访问元素都执行index-1操作，此处将_index的值设置为index-1 Triangular_iterator(int index):_index(index-1)&#123;&#125; bool operator==(const Triangular_iterator&amp;) const; bool operator!=(const Triangular_iterator&amp;) const; int operator*() const; Triangular_iterator&amp; operator++(); #++前置 Triangular_iterator operator++(int);#后置++private: void check_integrity() const; int _index;&#125;; inline bool Triangular_iterator :: operator==(const Triangular_iterator&amp; rhs) const &#123;return _index == rhs._index;&#125; #如果两个对象的_index相等，我们认为这两个对象相等 inline bool Triangular_iterator :: operator==(const Triangular_iterator&amp; rhs) const &#123;return！(*this== rhs);&#125;# 任何运算符如果和另一个运算符性质相反我们通常用后者来实现前者。 inline int Triangular_iterator :: operator*(const Triangular_iterator&amp; rhs) const &#123; check_integrity(); return Triangular::_elems[_index] &#125; inline void Triangular_iterator :: check_integrity() const &#123; if(_index&gt;=Triangular::_max_elems) throw iterator_overflow(); if(_index&gt;=Triangular::_elems.size()) Triangular::gen_elements(_index+1); &#125; inline Triangular_iterator&amp; Triangular_iterator :: operator++() &#123; //前置版本 ++_index; check_integrity(); return *this; &#125; inline Triangular_iterator&amp; Triangular_iterator :: operator++(int)//后置版本的参数列表本应是空的，但根据重载要求，参数列表必须独一无二，因此c++要求后置版本要有一个int参数 &#123; //后置版本 Triangular_interator tmp = *this; ++_index; check_integrity(); return tmp; &#125; 接下来对Triangular类进行修正12345678910111213141516171819202122#include \"Triangular_iterator.h\"class Triangular&#123;public: typedef Triangular_iterator iterator; Triangular_iterator begin()const &#123; return Triangular_iterator(_beg_pos); &#125; Triangular_iterator end)const &#123; return Triangular_iterator(_beg_pos+_length); &#125; //..... 人物志：胡歌-总有那么几个人，优秀到让你窒息。private: int _beg_pos; int _length; //...&#125;; 友元以下的non-member operator*可以直接访问Triangular的private _elems以及Triangular_iterator的pravate check_integrity(): 12345inlint int operator*(const Triangular_iterator &amp;rhs)&#123; rhs.check_integrity(); return Triangular::_elems[rhs.index()];&#125; 任何class都可以将其他fuction或者class制定为firend，这样这些class和function就有了与class member相同的访问权限，可以访问类的private member。为了让operator*()通过编译 我们需要将其设置为Triangular和Triangular_iterator的friend。12345678class Triangular&#123; friend int operator*(const Triangular_iterator &amp;rhs); //... &#125;; class Triangular_iterator&#123; friend int operator*(const Triangular_iterator &amp;rhs); //... &#125;; Triangular_iterator内的operator*()和check_integrity()都需要直接访问Triangular的private member因此我们将两者都声名为Triangular的friend。 12345class Triangular&#123; friend int Triangular_iterator::operator*(); friend int Triangular_iterator::cheack_integrity(); //... &#125;; 为了成功通过编译 我们必须在上述代码之前先提供Triangular_iterator的定义让T知道。我们也可以令class A 和class B建立firend关系。借此是的class A的所有member fuction都成为class B 的friend。1234class Triangular&#123; friend class Triangular_iterator; //... &#125;; 友谊的建立通常是为了效率考虑，如果我们只是希望进行某个data member的读取和写入，那么为它提供具有Public访问权限的inline函数，也是建立友谊之外的一个替代方案。 function object一种提供有fuction call运算符的class。当编译器在编译过程中遇到函数调用，如1lt(ival); lt可能是函数名称，可能是函数指针，也可能是一个提供了function call运算符的function object。如果lt是一个class object。编译器会在内部将此语句转化为1lt.operator(ival); function call运算符可以接受任意个数的参数。下面来实现一个function call运算符，测试传入的值是否小于某指定值。123456789101112131415161718192021222324252627282930class LessThan&#123;public: LessThan(int val):_val(val)&#123;&#125; int comp_val()const &#123;return _val;&#125;//读取基值 void comp_val(int nval)&#123;_val=nval;&#125;//基值的写入 bool operator()(int _value)const;private: int _val;&#125;;//fuction call 运算符的实现inline bool LessThan::operator()(int value) const &#123;return value&lt;_val;&#125;//function call 运算符应用到对象身上，便可调用function call运算符int count_less_than(const vector&lt;int&gt; &amp;vec,int comp)&#123; LessThan lt(comp); //定义一个对象并且初始化 int count = 0; for(int ix=0;ix&lt;vec.size();++ix) &#123; if(lt(vec[ix])) ++count; return count; &#125;&#125; 指针 指向Class Member Fuction","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"环境变量","slug":"环境变量","date":"2019-04-19T04:46:05.000Z","updated":"2019-04-19T07:10:13.342Z","comments":false,"path":"2019/04/19/环境变量/","link":"","permalink":"http://yoursite.com/2019/04/19/环境变量/","excerpt":"","text":"全局变量和局部变量bash shell用环境变量的特性来存储有关shell会话和工作环境的信息。在bash shell中，环境变量分为两类： 全局变量 局部变量 linxu系统在开始bash会话时就设置了一些全局环境变量。123456789env #查看所有全局变量printenv #查看所有全局变量$ printenv HOME # printenv命令也可以用来查看某个全局变量/home/mike$ echo $HOME #echo 命令不仅显示某个局部变量的值 同时让变量作为命令行参数/home/mikeset #set命令显示为某个特定进程设置的所有环境变量 包括局部变量 全局变量 以及用户自定义变量 用户自定义变量123456$ my_variable='Hello world'#变量名 等号 值之间不能有空格 值为含有空格的字符串 要用单引号括起来$ echo my_variableHello worle$ export my_variable #将局部变量导出到全局环境中unset my_variable #删除环境变量 子shell无法使用父shell中设置的用户自定义变量，在子shell中设置了局部变量，一旦退出子shell 这个局部变量便不可用。 在设定全局环境变量的进程所创建的子进程中，该变量均为可见的。修改或者删除子shell中的全局环境变量的值并不会影响到父shell中该变量的值。子shell无法使用export命令改变父shell中全局环境变量的值。 PATH环境变量设置当在shell命令行中输入一个外部命令时，shell必须搜索系统来找到对应的程序。PATH环境变量定义了用于进行命令和程序查找的目录 12$ echo $PATH #PATH中的目录间用冒号分隔/home/mike/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin 问题是应用程序放置可执行文件的目录常常不在PATH所包含的目录中。解决方法是保证PATH中包含了所有存放应用程序的目录。可以把新的搜索目录添加到现有的PATH目录中。无需从头定义。只需要引用原来的值，再给这个字符串添加新目录就可以了。1234567$ echo $PATH/home/mike/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin$$ PATH=$PATH:/home/mike/Scripts$$ echo $PATH/home/mike/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/mike/Scripts 通常的办法是将单点符加入PATH环境变量中，单点符代表当前目录。1PATH=$PATH:. 对PATH变量的修改只能持续到推出或者重启系统，并不能一直持续 系统环境变量当登陆linux系统时，bash shell会作为登陆shell启动，登陆shell会从5个不同的启动文件中读取命令： /ect/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile /ect/profile文件是系统默认的bash shell的主启动文件，每个用户登陆时都会执行这个启动文件。另外四个是启动文件是针对用户的。大多数linux发行版只用到其中的一两个。shell会按照下列顺序运行第一个被找到的文件，其他的被忽略： $HOME/.bash_profile $HOME/.bash_login $HOME/.profile这个列表中并没有- $HOME/.bashrc，因为该文件同从是通过其他文件启动的。 交互式shell(比如是在命令行提示符下敲入bash时启动)，只会检查 $HOME/.bashrc 文件非交互式shell(系统执行shell脚本时用的shell) bash shell 提供了BASH_ENV环境变量来为其提供查看启动文件的路径。若该变量没有被设置，由于子shell可以继承父shell导出的环境变量。如果父shell是登陆shell,则执行该脚本的子shell就可以继承登陆shell设置过并导出的变量。","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"系统管理命令","slug":"系统管理命令","date":"2019-04-18T12:22:49.000Z","updated":"2019-04-18T13:33:23.036Z","comments":false,"path":"2019/04/18/系统管理命令/","link":"","permalink":"http://yoursite.com/2019/04/18/系统管理命令/","excerpt":"","text":"监测进程1234ps -ef # 查看系统允许的所有进程top # 实时显示进程信息 按q退出kill UID #杀死指定进程号的进程 你必须为此进程的属主或root用户killall #结束所有进程 监测磁盘空间12345678mount -t type device directory #手动挂载媒体设备的基本命令mount -t vfat /dev/sdb1 /media/disk #手动将u盘/dev/sdb1挂载到/media/diskumount [directory|device] #卸载设备 只能在设备没有被占用的时候卸载umount /home/rich/mnt #卸载mnt设备df -h # 显示某个设备上还有多少磁盘空间du -ch #显示某个特定目录的磁盘使用情况 默认为当前目录du -s #显示某个特定目录的每个输出参数的总计 排序数据12sort -n file #将数字识别为数字 并按值排序sort -M file #将含有时间戳日期的文件按月份排序 搜索数据123456grep [options] pattern [file] #grep 命令行格式$ grep three filethree$ grep t file1twothree 压缩数据12345$ gzip my*$ ls -l my*-rwxrwxr-x 1 rich rich 2197 2007-09-13 11:29 myprog.gz-rwxrwxr-x 1 rich rich 5178 2007-09-13 11:29 myscript.gz-rwxrwxr-x 1 rich rich 60 2007-09-13 11:29 myscript2.gz 归档数据123tar -cvf test.tar test/ test2/ #创建名为test.tar的归档文件 含有test 和test2目录内容tar -tf test.tar #查看tar文件test.tar中的内容tar -xvf # 从tar文件中提取内容 在当前目录下重建","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"引用和指针的区别","slug":"引用和指针的区别","date":"2019-04-18T11:12:45.000Z","updated":"2019-04-18T11:40:43.144Z","comments":false,"path":"2019/04/18/引用和指针的区别/","link":"","permalink":"http://yoursite.com/2019/04/18/引用和指针的区别/","excerpt":"","text":"123int ival =1024; //初始化 int类型数据int *pi = &amp;ival; // pointer初始化 pi指向一个int对象int &amp;rval = ival; //reference 引用 代表一个int对象 通过by reference将对象作为函数参数传入时，函数可直接对传入的对象进行修改，也可以降低复制大型对象的负担。 也可以将对象以pointer的形式传递给函数，这与reference效果相同：传递的都是对象的地址，而不是整个对象的副本。两者区别为用法不同。 point参数和reference参赛之间更重要的差异是： pointer可能（也可能不）指向某个实际对象，当我们提领pointer时，一定要确定其值非0，而reference则必定会指向某个对象（不为null），所以不必作此检查 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化） 一旦引用被初始化，就不能改变引用的关系，即不能再指向其他对象（指针则可以随时改变所指的对象）","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"文件系统操作","slug":"文件系统操作","date":"2019-04-18T08:39:22.000Z","updated":"2019-04-18T10:08:46.984Z","comments":false,"path":"2019/04/18/文件系统操作/","link":"","permalink":"http://yoursite.com/2019/04/18/文件系统操作/","excerpt":"","text":"遍历目录1cd destiantion #cd 加目录名 可切换到目标目录 change dictionary destiantion可用相对目录和绝对目录来表示绝对目录路径以正斜线/开始，正斜线表示根目录，也可以～开始 表示家目录相对路径为基于当前位置的目标文件路径 单点符.表示当前目录 双点符表示当前目录的父目录。1pwd #print work dictionary 显示当前目录 基本列表功能12345ls #list 显示当前目录下的文件和目录ls -F # -F参数在目录名后加了正斜线/ 便于区分文件和目录ls -a # 显示所有文件 包括隐藏文件ls -R #列出当前目录下包含的子目录中的文件ls -l #显示长列表 每一行都包括一个文件的许多信息 处理文件123touch test #创建一个空的文件cp source destination # copy复制文件mv source destination #move 用来重命名或者移动文件 文件夹 处理目录12345mkdir 目录名 #新建一个目录mkdir -p #同时创建多个目录和子目录rmdir 目录名 #删除目录 默认只删除空目录rm -ir #删除目录及其所有内容tree #以树状图的形式显示目录子目录及其中的文件 需要手动安装 查看文件内容1234file my_file #查看文件类型cat test1 # 查看整个文件内容tail -n text #显示文件的最后n行head -n text #显示文件的前n行","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"frist blog","slug":"frist-blog","date":"2019-04-17T04:36:48.000Z","updated":"2019-04-18T09:17:04.364Z","comments":false,"path":"2019/04/17/frist-blog/","link":"","permalink":"http://yoursite.com/2019/04/17/frist-blog/","excerpt":"","text":"星期三, 17. 四月 2019 12:40下午my fist blog mike","categories":[{"name":"diary","slug":"diary","permalink":"http://yoursite.com/categories/diary/"}],"tags":[{"name":"-炮姐 -动漫","slug":"炮姐-动漫","permalink":"http://yoursite.com/tags/炮姐-动漫/"}]},{"title":"hexo基本操作","slug":"hexo-baseic","date":"2019-04-17T04:36:48.000Z","updated":"2019-04-18T11:42:49.352Z","comments":false,"path":"2019/04/17/hexo-baseic/","link":"","permalink":"http://yoursite.com/2019/04/17/hexo-baseic/","excerpt":"","text":"hexo cleanhexo ghexo shexo dhexo new “”星期三, 17. 四月 2019 11:13下午","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"-hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}