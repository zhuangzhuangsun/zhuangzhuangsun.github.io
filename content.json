{"meta":{"title":"韭菜熟了","subtitle":null,"description":null,"author":"mike","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"python中main的用法","slug":"python中main的用法","date":"2019-07-29T05:41:19.000Z","updated":"2019-07-29T05:45:44.889Z","comments":false,"path":"2019/07/29/python中main的用法/","link":"","permalink":"http://yoursite.com/2019/07/29/python中main的用法/","excerpt":"","text":"python程序是从上而下逐行运行的，在.py文件中，除了def后定义函数外的代码都会被认为是“main”方法中的内容从上而下执行。如果只是写”hello world”，不想写函数的话，仅仅是print(‘hello world’)就可以，这就是一个“程序”，不需要所谓的“main”方法入口。当然如果是测试函数功能就需要在.py文件中写上 1if __name__ == &quot;__main__&quot; 再调用函数。比如如下hello.py文件： 1234567891011print(\"first\") def sayHello(): str = \"hello\" print(str); print(__name__+'from hello.sayhello()') if __name__ == \"__main__\": print ('This is main of module \"hello.py\"') sayHello() print(__name__+'from hello.main') 运行结果： 12345firstThis is main of module \"hello.py\"hello__main__ from hello.sayhello()__main__ from hello.main 先执行的第一行print再执行“入口”中的东西 1234__name__其实是一个内置属性，指示当前py文件调用方式的方法。当某个py文件被执行时，该py文件的__name__属性，值都是__main__,当py文件作为模块被导入到另一个.py文件中（即import）比如说hell.py文件被导入到world.py中，运行world.py，此时hello.py中的__name__属性就会变成hello，所谓的入口因为if判断失败就不执行了所以if语句的判断成功虚拟了一个main（）方法。","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"tensorboard_tf.app.run","slug":"tensorflow-tf-app-run","date":"2019-07-29T05:00:48.000Z","updated":"2019-07-29T05:26:23.460Z","comments":false,"path":"2019/07/29/tensorflow-tf-app-run/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow-tf-app-run/","excerpt":"","text":"tf.app.flagstf.app.flags主要用于处理命令行参数的解析工作，其实可以理解为一个封装好了的argparse包（argparse是一种结构化的数据存储格式，类似于Json、XML）。 在tensorflow中我们该怎么使用呢？首先我们通过tf.app.flags来调用这个flags.py文件，这样我们就可以用flags.DEFINE_interger/float()来添加命令行参数，而FLAGS=flags.FLAGS可以实例化这个解析参数的类从对应的命令行参数取出参数。新建test.py文件，并输入如下代码，代码的功能是创建几个命令行参数，然后把命令行参数输出显示 123456789import tensorflow as tf flags = tf.app.flagsflags.DEFINE_string('data_dir', '/tmp/mnist', 'Directory with the MNIST data.')flags.DEFINE_integer('batch_size', 5, 'Batch size.')flags.DEFINE_integer('num_evals', 1000, 'Number of batches to evaluate.')FLAGS = flags.FLAGSprint(FLAGS.data_dir, FLAGS.batch_size, FLAGS.num_evals) 在命令行中输入test.py -h就可以查看帮助信息，也就是Directory with the MNIST data.，Batch size和Number of batches to evaluate这样的消息。 在命令行中输入test.py --batchsize 10就可以将batch_size的值修改为10！ tf.app.run()该函数一般都是出现在这种代码中： 12if __name__ == '__main__': tf.app.run() 上述第一行代码表示如果当前是从其它模块调用的该模块程序，则不会运行main函数！而如果就是直接运行的该模块程序，则会运行main函数。 具体第二行的功能从源码开始分析，源码如下： flags_passthrough=f._parse_flags(args=args)这里的parse_flags就是我们tf.app.flags源码中用来解析命令行参数的函数。所以这一行就是解析参数的功能； 下面两行代码也就是tf.app.run的核心意思：执行程序中main函数，并解析命令行参数！","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorflow队列和线程","slug":"tensorflow队列和线程","date":"2019-07-29T04:58:40.000Z","updated":"2019-07-29T05:32:14.560Z","comments":false,"path":"2019/07/29/tensorflow队列和线程/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow队列和线程/","excerpt":"","text":"队列和线程队列Tensorflow中的队列(queue)本身也是图中的一个节点，是一种有状态的节点，其他节点，如入队节点(enqueue)和出队节点(dequeue)都可以修改它的内容。入队节点可以把新元素插入到队列末尾，出队节点可以把队列前面的元素删除。 Tensorflow中主要有两种队列，即FIFOQueue和RandomShuffleQueue。 FIFOQueue FIFOQueue创建一个先入先出队列，当我们希望读入的训练样本为有序的，例如语音，文字样本。可以使用FIFOQueue。 12345678910111213141516171819import tensorflow as tf#创建一个FIFOQueue 初始化队列插入0.1，0.2，0.3三个数字q=tf.FIFOQueue(3,'float')init=q.enqueue_many(([0.1,0.2,0.3],))#定义出队，+1，入队操作 即将x出队加一后再入队x=q.dequeue()y=x+1q_inc=q.enqueue([y])#开启一个Session 执行两次q_inc操作 随后查看队列q的内容with tf.Session() as sess: sess.run(init) for i in range(2): sess.run(q_inc) quelen=sess.run(q.size()) fro i in range(quelen): print(sess.run(q.dequeue())) 1234输出为：0.31.11.2 RandomShuffleQueue RandomShuffleQueue创建一个随机队列，在出队列时，以随机的顺序产生元素，例如，在训练一些图像样本时，使用CNN，希望可以无序地读入训练样本，就可以使用RandomShuffleQueue,每次随机产生一个训练样本。 RandomShuffleQueue在Tensorflow使用异步计算时非常重要，因为Tensorflow会话是支持多线程的，可以在主线程里执行训练操作，使用RandomShuffleQueue作为训练输入，开多个线程来准备训练样本 123456789101112import tensorflow as tf#创建一个RandomShuffleQueue，队列最大长度为10 出队后最小长度为2q=tf.RandomShuffleQueue(capacity=10,min_after_dequeue=2,dtypes='float')#开启一个Session 执行两次q_inc操作 随后查看队列q的内容with tf.Session() as sess: for i in range(10): sess.run(q.enqueue(i)) for i in range(10): print(sess.run(q.dequeue())) 123456789输出为：6.07.02.04.01.08.03.05.0 ​ 我们尝试修改入队次数为12次，再次运行，发现程序阻断不动，或者我们尝试修改出队次数为10次，即不保留队列最小长度，发现队列输出八次结果后，在终端仍然阻断了，在箭头处卡住不动，称为阻断。 阻断一般发生在： 队列长度等于最小值时，执行出队操作 对列长度等于最大值时，执行入队操作 只有当队列满足要求后，才能继续执行，可以通过设置会话在运行时得等待时间来解除阻断 12345run_options=tf.RunOptions(timeout_in_ms=10000)#等待10stry: sess.run(q.dequeue(),options=run_options)except tf.errors.DeadlineExceededError: print('out of range') 队列管理器(QueueRunner)12345678910111213141516171819202122232425262728#首先创建一个含有队列的图q=tf.FIFOQueue(1000,'float')counter=tf.Variable(0.0)increment_op=tf.assign_add(counter,tf.constant(1.0))#操作给counter加一enqueue_op=q.enqueue([counter])#创建一个队列管理器QueueRunner，用这两个操作向队列q中添加元素，只使用一个线程qr=tf.train.QueueRunner(q,enqueue_ops=[increment_op,enqueue_op]*1)#启动一个会话，从队列管理器qr中创建线程with tf.Session() as sess: sess.run(tf.global_variable_initializer()) enqueue_threads=qr.create_threads(sess,start=true)#启动入队线程 #主线程 for i in range(10): print(sess.run(q.dequeue())) #输出为：2.03.03.04.05.06.07.07.08.010.0 输出并不是我们所期待的自然序列，并且线程被阻断，这是因为加一操作与入队操作不同步，可能加一操作执行了许多次之后，才会进行一次入队操作，另外因为主线程的训练(出队操作)和兑取数据的线程的训练(入队操作)时异步的，主线程会一直等待数据送入。","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorflow矩阵常用操作","slug":"tensorflow矩阵常用操作","date":"2019-07-29T04:57:49.000Z","updated":"2019-07-29T05:30:16.280Z","comments":false,"path":"2019/07/29/tensorflow矩阵常用操作/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow矩阵常用操作/","excerpt":"","text":"tensorflow矩阵运算点乘123456#对应元素相乘a = tf.constant([[1,2],[3,4]])b = tf.constant([[1,1],[2,2]])sess = tf.Session()print(sess.run(a*b))#或者sess.run(tf.multiply(a,b)) 乘法123c = tf.constant([[1,2],[3,4]])d = tf.constant([[1,1],[2,2]])print(sess.run(tf.matmul(c,d))) 加法123# 矩阵和向量相加，每列加上向量e = tf.constant([1,1])print(sess.run(tf.matmul(c,d)+e)) 转置1234567tf.transpose()transpose( a, perm=None, name='transpose')#参数表#a为待转置的矩阵 perm为一个List，例如[0，2，1]代表第一维度和第二维度交换 改变形状12345tf.reshape()#samplex=tf.get_variable('wc7_s', shape=[512,256],initializer=init_glorot_uniform)x=tf.reshape(x,[1,512,-1])#-1代表自适应 拼接1234tf.concat()#例子concact_1=tf.concat([uppool_1,maxpool5],3)#代表将uppool_1和maxpool5在第三维度上拼接 某个维度上复制1234tf.tile()map=tf.get_variable('map',shape=[5,4,3,2])map_copy=tf.tile(map,[1,1,1,6])#作用为将map在第3个通道上复制6遍 其余通道保持不变 map_copy的shape=[5,4,3,12] 转换数据类型1234tf.cast()#例子a=tf.Variable(5,name='a',dtype=tf.float32)tf.cast(a,tf.float64)","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorflow模型保存与加载","slug":"tensorflow模型保存与加载","date":"2019-07-29T04:57:04.000Z","updated":"2019-07-29T05:35:44.704Z","comments":false,"path":"2019/07/29/tensorflow模型保存与加载/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow模型保存与加载/","excerpt":"","text":"tensorflow模型的保存与加载模型文件A）元数据图（meta graph）：它保存了tensorflow完整的网络图结构。这个文件以.META为扩展名。 B）检查点文件（checkpoint file）这是一个二进制文件，它包含的权重变量，biases变量和其他变量。有两个文件 12mymodel.data-00000-of-00001mymodel.index C）检查点（checkpoint）checkpoint文件保存了一个目录下所有的模型文件列表，这个文件是tf.train.Saver类自动生成且自动维护的。在 checkpoint文件中维护了由一个tf.train.Saver类持久化的所有TensorFlow模型文件的文件名。当某个保存的TensorFlow模型文件被删除时，这个模型所对应的文件名也会从checkpoint文件中删除。 保存模型在训练模型的时候，需要一直关注着模型损失值和模型准确度。一旦你发现，网络已经收敛，就可以手动停止训练。训练完成后，我们希望将所有的变量和网络模型保存下来，供以后使用。在Tensorflow中要保存所有这些，使用tf.train.Saver（）来保存神经网络的网络结构图和相关变量。 1saver = tf.train.Saver() Tensorflow变量的作用范围是在一个session里面。在保存模型的时候，应该在session里面通过save方法保存。 1saver.save(sess, 'my-test-model') 在这里，sess是session对象，而“my-test-model”是模型的名称 如果我们希望在迭代1000次之后保存模型，可以把当前的迭代步数传进去。 1saver.save(sess, 'my_test_model',global_step=1000) 这样“-1000”将追加在文件名中： 1234my_test_model-1000.indexmy_test_model-1000.metamy_test_model-1000.data-00000-of-00001checkpoint 在训练的时候，假设每1000次就保存一次模型，但是，这些保存的文件中变化的只是神经网络的变量，而网络的结构是没有变化的，所以就没有必要重复保存.meta文件，可以使用下面的方式，只让网络结构保存一次。 1saver.save(sess, 'my-model', global_step=step,write_meta_graph=False) 如果你想只保留最新的4个模型，并希望每2小时保存一次，可以使用max_to_keep和keep_checkpoint_every_n_hours。 12#saves a model every 2 hours and maximum 4 latest models are saved.saver = tf.train.Saver(max_to_keep=4, keep_checkpoint_every_n_hours=2) 请注意，如果我们没有在tf.train.Saver（）指定任何参数，这样就表示要保存所有的变量。如果，我们不希望保存所有的变量，只是其中的一部分。我们可以指定要保存的变量或者集合。怎么做？在创建tf.train.Saver的时候我们把一个列表或者要保存变量的字典作为参数传进去。让我们来看一个例子： 1234567import tensorflow as tfw1 = tf.Variable(tf.random_normal(shape=[2]), name='w1')w2 = tf.Variable(tf.random_normal(shape=[5]), name='w2')saver = tf.train.Saver([w1,w2])sess = tf.Session()sess.run(tf.global_variables_initializer())saver.save(sess, 'my_test_model',global_step=1000) 这用于保存Tensorflow图的特定部分。 模型恢复ensorflow中有operation和tensor，前者表示 操作 ，后者表示 容器 ，每个operation都是有一个tensor来存放值的，比如y=f(x), operation是f(x), tensor存放的就是y，如果要获取y，就必须输入xtensor的名字一般是 : 可以通过 print(out.name) 来看看 假如之前的训练定义了如下图（模型），并保存： 1234567891011121314....bottom = layers.fully_connected(inputs=bottom, num_outputs=7, activation_fn=None, scope='logits_classifier')......prediction = tf.nn.softmax(logits, name='prob')......saver_path = './model/checkpoint/model.ckpt'saver = tf.train.Saver()config = tf.ConfigProto()config.gpu_options.allow_growth=Truewith tf.Session(config=config) as sess: sess.run(init)...... saved_path = saver.save(sess,saver_path) # 这个保存了三个东西， .meta是图的结构， 还有两个是模型中变量的值...... 要想图结构和模型（恢复图结构，没错，从空白的代码段中恢复一个graph，就不需要重新定义图了） 1234567891011121314meta_path = './model/checkpoint/model.ckpt.meta'model_path = './model/checkpoint/model.ckpt'saver = tf.train.import_meta_graph(meta_path) # 导入图config = tf.ConfigProto()config.gpu_options.allow_growth=Truewith tf.Session(config=config) as sess: saver.restore(sess, model_path) # 导入变量值 graph = tf.get_default_graph() prob_op = graph.get_operation_by_name('prob') # 这个只是获取了operation， 至于有什么用还不知道 prediction = graph.get_tensor_by_name('prob:0') # 获取之前prob那个操作的输出，即prediction print( ress.run(prediciton, feed_dict=&#123;...&#125;)) print(sess.run(graph.get_tensor_by_name('logits_classifier/weights:0'))) 关于获取保存的模型中的tensor或者输出，还有一种办法就是用tf.add_to_collection()，假如上面每次定义一次运算后，可以在后面添加tf.add_to_collection()： 1234567bottom = layers.fully_connected(inputs=bottom, num_outputs=7, activation_fn=None, scope='logits_classifier')### add collectiontf.add_to_collection('logits',bottom)......prediction = tf.nn.softmax(logits, name='prob')### add collectiontf.add_to_collection('prob',prediction) 恢复模型后，通过tf.get_collection()来获取tensor： 123456......x = tf.get_collection('inputs')[0]prob = tf.get_collection('prob')[0]print(x)print(prob)..... 可以查看输出，效果是和上面get_tensor_by_name()一样的，注意get_collection(name)的name只是collection的name，tensor的名字还是原来的名字 得到了模型各个地方的tensor之后，要想获取该地方的参数或者输出的值，只需要通过sess.run()就可以了，参数可以直接run，中间的特征或者预测值需要通过feed_dict={}传递输入的值就行啦","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorboard数据加载","slug":"tensorflow数据加载","date":"2019-07-29T04:55:34.000Z","updated":"2019-07-29T05:27:50.488Z","comments":false,"path":"2019/07/29/tensorflow数据加载/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow数据加载/","excerpt":"","text":"Tensorflow加载数据Tensorflow有三种读取数据的方法 预加载数据(preloaded data)。即在tensorflow图中定义常量或者变量来保存数据 填充数据(feeding)。python产生数据，再将数据填充到后端。 从文件中读取(reading from file)。从文件中直接读取，让队列管理器从文件中读取数据 预加载数据1234x1=tf.constant([2,3,4])x2=tf.constant([5,6,7])y=tf.add(x1,x2) 此方法缺点为将数据直接嵌入数据流图中，当数据较大时，比较消耗内存 填充数据使用sess.run()中的feed_dict参数，将python产生的数据填充入后端 123456789101112import tensorflow as tfa1=tf.placeholder(tf.int16)a2=tf.placeholder(tf.int16)b=tf.add(a1,a2)#数据li1=[2,3,4]li2=[5,6,7]with tf.Session() as sess: print(sess.run(b,feed_dict=&#123;a1:li1,a2:li2&#125;)) 此方法也有数据量大，消耗内存等缺点，并且数据类型转换等中间环节增加了不小的开销 从文件读取数据步骤： 把样本数据写入TFRecords二进制文件 从队列中读取数据 TFRecords是一种二进制文件，能更好地利用内存，更方便的复制和移动，并且不需要单独的标记文件。","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorflow控制流操作","slug":"tensorflow控制流操作","date":"2019-07-29T04:54:32.000Z","updated":"2019-07-29T05:30:47.520Z","comments":false,"path":"2019/07/29/tensorflow控制流操作/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow控制流操作/","excerpt":"","text":"123456789101112131415161718192021 i = 0 n =10 #循环条件函数 def cond(i, n): return i &lt; n#循环主体函数def body(i, n): i = i + 1 return i, n#[i,n]为循环输入的初始值i, n = tf.while_loop(cond, body, [i, n])'''tip:cond()函数的输入与body（）函数应该与循环输入初始值变量一一对应 此例中为[i,n]body（）函数的输出应与循环输入初始变量一致 此例中为[i,n]''' 12345678910n=tf.constant(np.max(superpixelmap),dtype=tf.int32)loss=tf.Variable(0.0,name='consistency_loss')def cond(i,loss,result,map): return i&lt;ndef body(i,loss,result,map): loss+=backend.a_superpixel_consistency_loss(result,map,i) return i+1,loss,result,mapi,loss,result,map=tf.while_loop(cond,body,(0,loss,result_student,superpixelmap))","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorboard张量定义及初始化","slug":"tensorflow张量定义及初始化","date":"2019-07-29T04:53:14.000Z","updated":"2019-07-29T05:28:36.780Z","comments":false,"path":"2019/07/29/tensorflow张量定义及初始化/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow张量定义及初始化/","excerpt":"","text":"张量定义及初始化123tf.Variable(initial_value=None, trainable=True, collections=None, validate_shape=True, caching_device=None, name=None, variable_def=None, dtype=None, expected_shape=None, import_scope=None) 123tf.get_variable(name, shape=None, dtype=None, initializer=None, regularizer=None, trainable=True, collections=None, caching_device=None, partitioner=None, validate_shape=True, custom_getter=None) 使用tf.Variable时，如果检测到命名冲突，系统会自己处理。使用tf.get_variable()时，系统不会处理冲突，而会报错 tf.Variable() 每次都在创建新对象，所有reuse=True 和它并没有什么关系。对于get_variable()，来说，如果已经创建的变量对象，就把那个对象返回，如果没有创建变量对象的话，就创建一个新的 1234#常量定义D = tf.zeros([2, 2], dtype=tf.float32)E = tf.ones([2, 2], dtype=tf.float32)F = tf.constant([[1, 2], [3, 4]], dtype=tf.float32)","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorflow命名空间","slug":"tensorflow命名空间","date":"2019-07-29T04:51:57.000Z","updated":"2019-07-29T05:29:58.396Z","comments":false,"path":"2019/07/29/tensorflow命名空间/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorflow命名空间/","excerpt":"","text":"TensorFlow的命名空间分为两种，tf.variable_scope和tf.name_scope。 tf.variable_scope当使用tf.get_variable定义变量时，如果出现同名的情况将会引起报错 而对于tf.Variable来说，却可以定义“同名”变量，但是把这些图变量的name属性打印出来，就可以发现它们的名称并不是一样的。 如果想使用tf.get_variable来定义另一个同名图变量，可以考虑加入新一层scope，比如： 12345678In [1]: import tensorflow as tfIn [2]: with tf.variable_scope('scope1'): ...: v1 = tf.get_variable('var', shape=[1]) ...: with tf.variable_scope('scope2'): ...: v2 = tf.get_variable('var', shape=[1]) ...:In [3]: v1.name, v2.nameOut[3]: ('scope1/var:0', 'scope1/scope2/var:0') tf.name_scope当tf.get_variable遇上tf.name_scope，它定义的变量的最终完整名称将不受这个tf.name_scope的影响，如下： 123456789In [1]: import tensorflow as tfIn [2]: with tf.variable_scope('v_scope'): ...: with tf.name_scope('n_scope'): ...: x = tf.Variable([1], name='x') ...: y = tf.get_variable('x', shape=[1], dtype=tf.int32) ...: z = x + y ...:In [3]: x.name, y.name, z.nameOut[3]: ('v_scope/n_scope/x:0', 'v_scope/x:0', 'v_scope/n_scope/add:0')","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"tensorboard使用","slug":"tensorboard使用","date":"2019-07-29T04:47:25.000Z","updated":"2019-07-29T05:31:29.472Z","comments":false,"path":"2019/07/29/tensorboard使用/","link":"","permalink":"http://yoursite.com/2019/07/29/tensorboard使用/","excerpt":"","text":"TensorBoard的使用使用TensorBoard展示数据，需要在执行Tensorflow计算图的过程中，将各种类型的数据（summary protobuf）汇总并记录到日志文件中。然后使用TensorBoard读取这些日志文件，解析数据并生产数据可视化的Web页面，让我们可以在浏览器中观察各种汇总数据。 tensorboard可视化的数据类型 SCALARS，对标量数据进行汇总和记录使用方法：tf.summary.scalar(tags, values, collections=None, name=None) IMAGES， 汇总数据中的图像，例如MNIST中可以将输入的向量还原成图片的像素矩阵使用方法：tf.summary.image(tag, tensor, max_images=3, collections=None, name=None) GRAPHS， 可视化Tensorflow计算图的结构及计算图上的信息使用方法：tf.summary.FileWriter(logdir, graph)其实这个方法是将当前summary protobuf写近日志文件中，但是会自动生成计算图。 HISTOGRAMS，记录变量的直方图(张量中元素的取值分布）使用方法：tf.summary.histogram(tag, values, collections=None, name=None） merge_all()和Tensorflow类似，tf.summaru.histograms()等函数不会立即执行，需要通过sess.run()来明确调用，当日志程序中定义写日志的操作比较多时，可以使用summ = tf.summary.merge_all()函数来整理所有的日志生成操作，最后只需要sess.run(summ)即可将定义中的所有日志生成操作一次执行。 使用步骤 添加记录节点：tf.summary.scalar/image/histogram()等 汇总记录节点：merged = tf.summary.merge_all() 运行汇总节点：summary = sess.run(merged)，得到汇总结果 日志书写器实例化：summary_writer = tf.summary.FileWriter(logdir, graph=sess.graph)，实例化的同时传入 graph 将当前计算图写入日志 调用日志书写器实例对象summary_writer的add_summary(summary, global_step=i)方法将所有汇总日志写入文件 调用日志书写器实例对象summary_writer的close()方法写入内存，否则它每隔120s写入一次 12345678910111213141516171819#exampleimport tensorflow as tf#定义命名空间with tf.name_scope('input'): #fetch：就是同时运行多个op的意思 input1 = tf.constant(3.0,name='A')#定义名称，会在tensorboard中代替显示 input2 = tf.constant(4.0,name='B') input3 = tf.constant(5.0,name='C')with tf.name_scope('op'): #加法 add = tf.add(input2,input3) #乘法 mul = tf.multiply(input1,add)with tf.Session() as sess: #默认在当前py目录下的logs文件夹，没有会自己创建 wirter = tf.summary.FileWriter('logs/',sess.graph) result = ss.run([mul,add]) print(result) 1tensorboard --logdir=路径 在浏览器中使用http://DESKTOP-JGL4HV5:6006查看可视化结果 123456789101112131415161718192021222324252627282930313233343536373839404142import tensorflow as tfimport numpy as np## prepare the original datawith tf.name_scope('data'): x_data = np.random.rand(100).astype(np.float32) y_data = 0.3*x_data+0.1##creat parameterswith tf.name_scope('parameters'): with tf.name_scope('weights'): weight = tf.Variable(tf.random_uniform([1],-1.0,1.0)) tf.summary.histogram('weight',weight) with tf.name_scope('biases'): bias = tf.Variable(tf.zeros([1])) tf.summary.histogram('bias',bias)##get y_predictionwith tf.name_scope('y_prediction'): y_prediction = weight*x_data+bias##compute the losswith tf.name_scope('loss'): loss = tf.reduce_mean(tf.square(y_data-y_prediction)) tf.summary.scalar('loss',loss)##creat optimizeroptimizer = tf.train.GradientDescentOptimizer(0.5)#creat train ,minimize the loss with tf.name_scope('train'): train = optimizer.minimize(loss)#creat initwith tf.name_scope('init'): init = tf.global_variables_initializer()##creat a Session sess = tf.Session()#mergedmerged = tf.summary.merge_all()##initializewriter = tf.summary.FileWriter(\"logs/\", sess.graph)sess.run(init)## Loopfor step in range(101): sess.run(train) rs=sess.run(merged) writer.add_summary(rs, step)","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/categories/tensorflow/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"关于python的引用","slug":"关于python的引用","date":"2019-06-13T12:10:04.000Z","updated":"2019-06-13T12:54:19.933Z","comments":false,"path":"2019/06/13/关于python的引用/","link":"","permalink":"http://yoursite.com/2019/06/13/关于python的引用/","excerpt":"python不允许程序员选择传值还是传引用。python参数传递参用的肯定是“传对象引用”的方式。如果函数收到的是一个可变对象(字典或者列表)的引用，就可以修改对象的原始值，若为不可变对象(如元组或者字符)，则不可直接修改对象。 当复制列表或者字典时，就复制了对象列表的引用，如果改变引用的值，则修改了原始的参数。 为了简化内存管理，Python通过引用计数器的方式实现垃圾自动回收。Python对每个对象都有一个引用计数，每当其被引用一次，计数值就会加一，每销毁一次Python对象，计数值就会减一，当计数值为零时，才从内存中删除Python对象。","text":"python不允许程序员选择传值还是传引用。python参数传递参用的肯定是“传对象引用”的方式。如果函数收到的是一个可变对象(字典或者列表)的引用，就可以修改对象的原始值，若为不可变对象(如元组或者字符)，则不可直接修改对象。 当复制列表或者字典时，就复制了对象列表的引用，如果改变引用的值，则修改了原始的参数。 为了简化内存管理，Python通过引用计数器的方式实现垃圾自动回收。Python对每个对象都有一个引用计数，每当其被引用一次，计数值就会加一，每销毁一次Python对象，计数值就会减一，当计数值为零时，才从内存中删除Python对象。 python中变量和对象名是分开的。1a=1 这是一个赋值语句，整数1为一个对象，a为一个引用，利用赋值语句，将a指向了对象1,这相当于放风筝，变量a为手中的线，通过引用来接触和拴住天空中的风筝–对象。 可以通过python内置函数id()来查看对象在内存中的地址。123456&gt;&gt;&gt;a=2&gt;&gt;&gt;id(a)24834392&gt;&gt;&gt;a='banana'&gt;&gt;&gt;id(a)139990659655312 第一个语句中， 2是储存在内存中的一个整数对象，通过赋值 引用a 指向了 对象 1 第二个语句中，内存中建立了一个字符串对象‘banana’，通过赋值 将 引用a 指向了 ‘banana’，同时，对象1不在有引用指向它，它会被python的内存处理机制给当我垃圾回收，释放内存。 123456&gt;&gt;&gt;a=2&gt;&gt;&gt;id(a)24834392b=2&gt;&gt;&gt;id(b)24834392 在这里可以看到 这俩个引用 指向了同一个 对象，这是为什么呢？ 这个跟python的内存机制有关系，因为对于语言来说，频繁的进行对象的销毁和建立，特别浪费性能。所以在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。123456&gt;&gt;&gt; a = 4&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)36151568&gt;&gt;&gt; id(b)36151568 a 和 b 都指向了 整数对象 4 12345&gt;&gt;&gt; a = a+2&gt;&gt;&gt; id(a)36151520&gt;&gt;&gt; id(b)36151568 可以看到 a 的引用改变了，但是 b 的引用未发生改变；a，b指向不同的对象； 第3句对 a 进行了重新赋值，让它指向了新的 对象6；即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用指向一个新的引用，并不影响其他的引用的指向。从效果上看，就是各个引用各自独立，互不影响。 123456&gt;&gt;&gt; L1 = [1,2,3]&gt;&gt;&gt; L2 = L1&gt;&gt;&gt; id(L1)139643051219496&gt;&gt;&gt; id(L2)139643051219496 此时 L1 和 L2 的引用相同，都是指向 [1,2,3]这个列表对象。 1234567&gt;&gt;&gt; L1[0] = 10&gt;&gt;&gt; id(L1)139643051219496&gt;&gt;&gt; id(L2)139643051219496&gt;&gt;&gt; L2[10, 2, 3] 同样的跟第四个栗子那样，修改了其中一个对象的值，但是可以发现 结果 并不与 第四个栗子那样， 在本次实验中，L1 和 L2 的引用没有发生任何变化，但是 列表对象[1,2,3] 的值 变成了 [10,2,3]（列表对象改变了） 在该情况下，我们不再对L1这一引用赋值，而是对L1所指向的表的元素赋值。结果是，L2也同时发生变化。 原因何在呢？因为L1，L2的指向没有发生变化，依然指向那个表。表实际上是包含了多个引用的对象（每个引用是一个元素，比如L1[0]，L1[1]…, 每个引用指向一个对象，比如1,2,3), 。而L1[0] = 10这一赋值操作，并不是改变L1的指向，而是对L1[0], 也就是表对象的一部份(一个元素)，进行操作，所以所有指向该对象的引用都受到影响。 （与之形成对比的是，我们之前的赋值操作都没有对对象自身发生作用，只是改变引用指向。） 列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。 而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。 我们之前学的元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object.","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"构建基本脚本","slug":"构建基本脚本","date":"2019-05-29T08:39:22.000Z","updated":"2019-05-29T14:30:36.151Z","comments":false,"path":"2019/05/29/构建基本脚本/","link":"","permalink":"http://yoursite.com/2019/05/29/构建基本脚本/","excerpt":"","text":"使用多个命令如果要两个命令一起运行，可以将它们放在同一行，中间使用分号隔开1$ date;who 创建shell脚本创建shell脚本文件时，必须在第一行指定要使用的shell。其格式为1#!/bin/bash 通常在shell脚本中，井号用作注释行在指定shell后，就可以在每一行输入命令1234#!/bin/bash# this script displays the data and who is logged ondatawho 将这个脚本存储为test1的文件中，运行12$ ./test1bash: ./test1:Permission denied shell指明了没有执行文件的权限。查看一下文件权限123$ls -l test1-rw-r--r-- 1 mike mike 75 5月 29 20:43 text1$ 通过chmod命令赋予文件属主执行文件的权限1234$chmod u+x test1$./test12019年 05月 29日 星期三 20:51:42 CSTmike :0 2019-05-29 20:18 (:0) 显示消息通过echo命令，将脚本输出显示在控制台上1234567891011121314151617$echo This is a testThis is a test#有引号的情况$echo \"let's see if this'll work\"let's see if this'll work$echo 'Rich says \"scripting is easy\".'Rich says \"scripting is easy\".#如果想要将文本字符串和命令输出显示在同一行中，应使用echo命令的-n参数#!/bin/bashecho The time and data are:date#该脚本运行结果为The time and date are:2019-05-29 20:18 (:0) 使用变量 环境变量 可以在环境变量名称之前加上美元符号($)来使用这些美元符号1234#!/bin/bashecho \"User info for userid: $USER\"echo UID: $UIDecho HOME: $HOME 脚本输出如下12345$chmod u+x test2$./test2User info for userid:mikeUID:1001HOME:/home/mike 如果要在脚本中使用美元符号 则要前面加上一个反斜线12echo 'the cost of the item is /$15'the cost of the item is $15 用户变量 shell允许在脚本中定义和使用自己的变量。用户变量可以由任何字母，数字和下划线组成，长度不超过20。区分大小写。用等号将值赋给用户变量。在变量，等号，和值之间不能出现空格。123456789$vim test2#!/bin/bash#assigning a variable value to anther variablevalue1=10value2=$value2string1=“hello”string2=$string1 命令替换 将命令输出信息赋给变量123#两种方法testing=`date` #`为反引号 位于tab上方testing=$(date) 输入和输出重定向 输出重定向 12command&gt;outputfile #命令输出保存到指定输出文件中command&gt;&gt;outputfile#命令输出追加在已有文件中 输入重定向 12command&lt;inputfilecommand&lt;&lt;marker 管道将命令输出重定向到另一个命令中1command1|command2 退出脚本linux提供了一个专门的变量$? 来保存上个已执行命令的推出状态码按照惯例一个成功结束的命令的推出状态码是012345echo $?#查看上条命令的退出状态码exit var1 #使用var1的值作为退出状态码 默认情况下 shell脚本会以脚本中最后一个命令的退回状态码退出。可以使用exit命令在脚本结束时指定一个退回状态码 退出状态玛为一个0~255的整数。","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"linux包管理系统","slug":"linux包管理系统","date":"2019-04-27T02:35:12.000Z","updated":"2019-04-27T04:32:27.488Z","comments":false,"path":"2019/04/27/linux包管理系统/","link":"","permalink":"http://yoursite.com/2019/04/27/linux包管理系统/","excerpt":"","text":"linux的包管理系统各种主流linux发行版都采用了某种形式的包管理系统(package management system,PMS)来控制软件和库的安装。PMS利用一个数据库来记录各种相关内容。 Linux系统上已经安装了哪些包 每个包安装了哪些文件 每个已安装软件包的版本软件包存储在服务器上，可以利用本地系统的PMS工具通过互联网访问。可以用PMS来搜索新的软件包，或者更新已有的软件包。软件包通常会依赖其它的包。PMS会检测依赖关系，在安装需要的包前，安装好其依赖的包。PMS目前还没有统一的标准工具。linux中广泛使用的两种PMS基础工具是dpkg和rpm。基于Debian的发行版(如ubuntu)使用的是dpkg命令，基于Red Hat的发行版(如Fedorn openSUSE Mandriva)使用的是rpm命令。这两个命令各是其PMS的核心，而并非全部的PMS。 基于Debian的系统dpkg命令是基于Debian系PMS工具的核心。包含在这个PMS上其它工具有： apt-get apt-cache aptitude最常用的命令行工具为aptitude。其本质上为apt工具和dpkg的前端。dpkg是软件包管理系统工具，而aptitude是完整的软件包管理系统。 用aptitude管理软件包 在安装有aptitude的linux的shell中输入aptitude并回车便可以计入aptitude的界面。aptitude无法看到的细节是所有跟某个特定软件包相关的所有文件的列表。我们可以用dpkg命令来得到这个列表。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192dpkg -L package_name #命令格式$$dpkg -L vim-common #列出vim-common软件包安装的全部文件/./etc/etc/vim/etc/vim/vimrc/usr/usr/bin/usr/bin/helpztags/usr/lib/usr/lib/mime/usr/lib/mime/packages/usr/lib/mime/packages/vim-common/usr/share/usr/share/applications/usr/share/applications/vim.desktop/usr/share/doc/usr/share/doc/vim-common/usr/share/doc/vim-common/NEWS.Debian.gz/usr/share/doc/vim-common/README.Debian/usr/share/doc/vim-common/changelog.Debian.gz/usr/share/doc/vim-common/copyright/usr/share/icons/usr/share/icons/hicolor/usr/share/icons/hicolor/48x48/usr/share/icons/hicolor/48x48/apps/usr/share/icons/hicolor/48x48/apps/gvim.png/usr/share/icons/hicolor/scalable/usr/share/icons/hicolor/scalable/apps/usr/share/icons/hicolor/scalable/apps/gvim.svg/usr/share/icons/locolor/usr/share/icons/locolor/16x16/usr/share/icons/locolor/16x16/apps/usr/share/icons/locolor/16x16/apps/gvim.png/usr/share/icons/locolor/32x32/usr/share/icons/locolor/32x32/apps/usr/share/icons/locolor/32x32/apps/gvim.png/usr/share/lintian/usr/share/lintian/overrides/usr/share/lintian/overrides/vim-common/usr/share/man/usr/share/man/fr/usr/share/man/fr/man1/usr/share/man/fr/man1/vim.1.gz/usr/share/man/fr/man1/vimdiff.1.gz/usr/share/man/it/usr/share/man/it/man1/usr/share/man/it/man1/vim.1.gz/usr/share/man/it/man1/vimdiff.1.gz/usr/share/man/ja/usr/share/man/ja/man1/usr/share/man/ja/man1/vim.1.gz/usr/share/man/ja/man1/vimdiff.1.gz/usr/share/man/man1/usr/share/man/man1/helpztags.1.gz/usr/share/man/man1/vim.1.gz/usr/share/man/man1/vimdiff.1.gz/usr/share/man/pl/usr/share/man/pl/man1/usr/share/man/pl/man1/vim.1.gz/usr/share/man/pl/man1/vimdiff.1.gz/usr/share/man/ru/usr/share/man/ru/man1/usr/share/man/ru/man1/vim.1.gz/usr/share/man/ru/man1/vimdiff.1.gz/usr/share/pixmaps/usr/share/pixmaps/gvim.svg/usr/share/pixmaps/vim-16.xpm/usr/share/pixmaps/vim-32.xpm/usr/share/pixmaps/vim-48.xpm/usr/share/vim/usr/share/vim/vim80/usr/share/vim/vim80/debian.vim/var/var/lib/var/lib/vim/var/lib/vim/addons/usr/share/man/fr/man1/rview.1.gz/usr/share/man/fr/man1/rvim.1.gz/usr/share/man/it/man1/rview.1.gz/usr/share/man/it/man1/rvim.1.gz/usr/share/man/ja/man1/rview.1.gz/usr/share/man/ja/man1/rvim.1.gz/usr/share/man/man1/rview.1.gz/usr/share/man/man1/rvim.1.gz/usr/share/man/pl/man1/rview.1.gz/usr/share/man/pl/man1/rvim.1.gz/usr/share/man/ru/man1/rview.1.gz/usr/share/man/ru/man1/rvim.1.gz/usr/share/vim/vimfiles/usr/share/vim/vimrc 同样可以反向操作，查找某个特定文件属于那个软件包。1dpkg --search absolute_file_name #注意在使用的时候必须使用绝对路径 用aptittude安装软件包首先要确定准备安装的包的名字，用aptitude命令加search选项来寻找特点的软件包。1aptitude search package_name search选项的好处在于无需在package_name周围加通配符，通配符会隐式添加。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$aptitude search winep fonts-wine - Windows API implementation - fonts v fonts-wine:i386 - p gnome-wine-icon-theme - red variation of the GNOME-Colors icon thep libkwineffects11 - KDE window manager effects library p libkwineffects11:i386 - KDE window manager effects library p libwine - Windows API implementation - library p libwine:i386 - Windows API implementation - library p libwine-dev - Windows API implementation - development fp libwine-dev:i386 - Windows API implementation - development fv libwine-dev:i386 - p libwine-development - Windows API implementation - library p libwine-development:i386 - Windows API implementation - library p libwine-development-dev - Windows API implementation - development fp libwine-development-dev:i386 - Windows API implementation - development fv libwine-development-dev:i386 - p q4wine - Qt GUI for wine (WINE) p q4wine:i386 - Qt GUI for wine (WINE) p shiki-wine-theme - red variation of the Shiki-Colors theme p twine - utility for interacting with PyPI v wine - v wine:i386 - v wine-amd64 - p wine-binfmt - Windows API implementation - binfmt supporv wine-dev - v wine-dev:i386 - p wine-development - Windows API implementation - standard suitv wine-development:i386 - v wine-i386:i386 - p wine-stable - Windows API implementation - standard suitv wine-stable:i386 - v wine1.4 - v wine1.4:i386 - v wine1.4-amd64 - v wine1.4-dev - v wine1.4-dev:i386 - v wine1.4-i386:i386 - v wine1.4:any - v wine1.5-amd64 - v wine1.5-i386:i386 - p wine1.6 - Windows API implementation (transitional pp wine1.6:i386 - Windows API implementation (transitional pp wine1.6-amd64 - Windows API implementation (transitional pp wine1.6-dev - Windows API implementation (transitional pp wine1.6-dev:i386 - Windows API implementation (transitional pv wine1.6-i386 - p wine1.6-i386:i386 - Windows API implementation (transitional pv wine1.6:any - v wine1.7 - v wine1.7:i386 - v wine1.7-amd64 - v wine1.7-dev - v wine1.7-dev:i386 - v wine1.7-i386:i386 - v wine1.7:any - v wine1.8 - v wine1.8:i386 - v wine1.8-amd64 - v wine1.8-dev - v wine1.8-dev:i386 - v wine1.8-i386:i386 - v wine1.8:any - v wine32 - p wine32:i386 - Windows API implementation - 32-bit binaryv wine32-development - p wine32-development:i386 - Windows API implementation - 32-bit binaryp wine32-development-preloader:i3 - Windows API implementation - prelinked 32-v wine32-development-tools - p wine32-development-tools:i386 - Windows API implementation - 32-bit develop wine32-preloader:i386 - Windows API implementation - prelinked 32-v wine32-tools - p wine32-tools:i386 - Windows API implementation - 32-bit develop wine64 - Windows API implementation - 64-bit binaryp wine64-development - Windows API implementation - 64-bit binaryp wine64-development-preloader - Windows API implementation - prelinked 64-p wine64-development-tools - Windows API implementation - 64-bit develov wine64-development-tools:i386 - p wine64-preloader - Windows API implementation - prelinked 64-p wine64-tools - Windows API implementation - 64-bit develov wine64-tools:i386 - p winefish - LaTeX Editor based on Bluefish p winefish:i386 - LaTeX Editor based on Bluefish p winetricks - package manager for Wine to install softwav winetricks:i386 - 每个包名字前都有一个p或i，如果看到i说明这个包已经安装到我们的系统上了。p或v，说明这个包可用但是还没有安装。 接着安装这个包1sudo aptitude install package_name 要检查安装是否成功，再次使用search命令就可以了，会看到安装的包前有一个i说明安装成功。 用aptitude更新软件1sudo aptitude safe-upgrade 该命令会将所有已安装的包更新到软件库最新版本 用aptitude卸载软件12sudo aptitude purge package_name#删除软件包及相关数据和配置文件sudo aptitude remove package_name#只删除软件包而保留相关数据和配置文件 要看软件包是否被删除 可以再看aptitude的search选项，如果在软件包前看见一个c，意味着已经被删除但配置文件尚未删除，如果前面为p，说明配置文件也已经删除。 aptitude仓库aptitude默认的软件仓库位置是在安装linux发行版时候设置的，具体存储位置在/ect/apt/sources.list中。 aptitude只会从这些仓库中下载文件，搜索软件进行安装或更新时，也只会检查这些库，如果需要为PMS添加一些额外的软件仓库，可以在这个文件中设置。 基于Red Hat的系统","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"python读取matlab数据","slug":"python读取matlab数据","date":"2019-04-26T10:09:34.000Z","updated":"2019-04-26T10:12:56.743Z","comments":false,"path":"2019/04/26/python读取matlab数据/","link":"","permalink":"http://yoursite.com/2019/04/26/python读取matlab数据/","excerpt":"","text":"使用 scipy.io 在python读取Matlab中.mat数据方法1234567891011121314151617import scipy.ioimport numpy as npf = scipy.io.loadmat('T.mat')#T.mat在工作目录中print(type(f))out:&lt;class 'dict'&gt; #f的数据类型为字典类型data=f['T'] #文件名T为字典的Key 通过key来获得了数据type(data) #data的数据类型为ndarrayout:numpy.ndarray data.shape out:1300*1200 data.sizeout:156000","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}]},{"title":"VAT算法","slug":"VAT算法","date":"2019-04-26T10:09:03.000Z","updated":"2019-04-26T10:26:47.289Z","comments":false,"path":"2019/04/26/VAT算法/","link":"","permalink":"http://yoursite.com/2019/04/26/VAT算法/","excerpt":"","text":"VAT (visual assessment of cluster)transform the dissimilarity image into the Reorder Dissimilarity Image123456789101112131415161718192021222324252627282930313233343536373839404142434445464748%% \"\"\" VAT \"\"\"% % PROGRAM DESCRIPTION% This is a MATLAB implementation of Visual Assessment of cluster Tendency (VAT).%% INPUT% D: NxN dissimilarity matrix%% REFERENCES% [1] J. C. Bezdek and R. J. Hathaway, \"VAT: a tool for visual assessment% of (cluster) tendency\", Proc. Int. Joint Conf. Neural Netw. (IJCNN), % vol. 3, 2002, pp. 2225-2230.%% Code written by Leonardo Enzo Brito da Silva% Under the supervision of Dr. Donald C. Wunsch II%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% VAT reordering algorithm function [Dstar, P, N] = VAT(D) % Setup N = size(D, 1); K = 1:N; P = zeros(1, N); % Starting point [~, ind] = max(D(:)); [i, ~] = ind2sub([N N], ind); P(1) = i; I(1) = i; J = K; J(J==i) = []; % Main VAT Loop for r=2:N Dtemp = D(I, J); [~, ind] = min(Dtemp(:)); [~, j_temp] = ind2sub(size(Dtemp), ind); j = J(j_temp); P(r) = j; I = [I; j]; J(J==j) = []; end % Output Dstar = D(P, P); end","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"SAR","slug":"SAR","permalink":"http://yoursite.com/tags/SAR/"}]},{"title":"wishart_distance","slug":"wishart-distance","date":"2019-04-26T10:08:48.000Z","updated":"2019-04-26T10:14:35.906Z","comments":false,"path":"2019/04/26/wishart-distance/","link":"","permalink":"http://yoursite.com/2019/04/26/wishart-distance/","excerpt":"","text":"wishart distance python函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import numpy as npdef wish_dist(Wi,Wj,k=4): \"\"\"function to find the Wishart between two covariance matrice Returns distance Parameters ---------- Wi,Wj : comaplex amtrix covariance matrices k : int distance definition type to be used for calculation. Returns ------- data : float distance \"\"\" # sum of covariance matrices Wij = Wi+Wj # log of determinant probably log_j =np.log(Wj[0,0]*Wj[1,1]*Wj[2,2]*(1-np.square((np.real(Wj[0,2]))) )) # this is actually: log(det(Wj)) &gt;&gt;Using analytically reduced form (Rignot and Chellappa, 1992) log_i = np.log(Wi[0,0]*Wi[1,1]*Wi[2,2]*(1-np.square((np.real(Wi[0,2]))) )) # this is actually: Log(Wi) &gt;&gt;Using analytically reduced form (Rignot and Chellappa, 1992) log_ij =np.log(Wij[0,0]*Wij[1,1]*Wij[2,2]*(1-np.square((np.real(Wij[0,2]))) )) # absolute of trace of inverse matrices tri = np.abs(np.trace(np.linalg.pinv(Wj)*Wi)) trj = np.abs(np.trace(np.linalg.pinv(Wi)*Wj)) if k ==1: # default Wishart distance dist = log_j + tri if k == 2: # symmetric Wishart distance dist =.5*(log_i + log_j + tri + trj) if k == 3: # Bartlett distance dist = 2*log_ij - log_i - log_j if k == 4: # revised Wishart distance dist = log_j - log_i + tri if k == 5: # another dstance dist = tri + trj return dist","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"SAR","slug":"SAR","permalink":"http://yoursite.com/tags/SAR/"}]},{"title":"numpy的布尔值索引","slug":"numpy的布尔值索引","date":"2019-04-26T10:08:38.000Z","updated":"2019-04-26T10:39:07.286Z","comments":false,"path":"2019/04/26/numpy的布尔值索引/","link":"","permalink":"http://yoursite.com/2019/04/26/numpy的布尔值索引/","excerpt":"","text":"numpy的布尔值索引1234567891011121314151617181920import mumpy as npA=np.array([1,1,2,2,3,3,4,4])print('A=',A)print('shape of A:',A.shape)A.resize(2,4)print('A=',A)print('shape of A:',A.shape)x=(A[0,:]==1)print('x=',x)print('A[1,x]=',A[1,x])out:A= [1 1 2 2 3 3 4 4]shape of A: (8,)A= [[1 1 2 2] [3 3 4 4]]shape of A: (2, 4)x= [ True True False False]A[1,x]= [3 3]","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"http://yoursite.com/tags/numpy/"}]},{"title":"matlab_find命令","slug":"matlab-find命令","date":"2019-04-26T10:08:20.000Z","updated":"2019-04-26T10:39:54.125Z","comments":false,"path":"2019/04/26/matlab-find命令/","link":"","permalink":"http://yoursite.com/2019/04/26/matlab-find命令/","excerpt":"","text":"matlab的find 和 sizematlab的一些小tip 1，索引从1开始。 2，没有python中 x.方法 的用法 3，矩阵 数组 的索引都用小括号() 1234567891011121314151617181920212223242526272829303132333435363738%find - Find indices and values of nonzero elements%% This MATLAB function returns a vector containing the linear indices of % each nonzero element in array X.%% k = find(X)% k = find(X,n)% k = find(X,n,direction)% [row,col] = find(___)% [row,col,v] = find(___)&gt;&gt;x=[1 2 3 1 2 3]x = 1 2 3 1 2 3&gt;&gt;y=find(x==1)y = 1 4&gt;&gt;x(y)ans = 1 1&gt;&gt;B=reshape(x,2,3)B = 1 3 2 2 1 3&gt;&gt; [row,col]=find(B==1)row = 1 2col = 1 2 size This MATLAB function returns a row vector whose elements contain the length of the corresponding dimension of A. 1234sz = size(A)szdim = size(A,dim)[m,n] = size(A)[sz1,...,szN] = size(A)","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"matalb","slug":"matalb","permalink":"http://yoursite.com/tags/matalb/"}]},{"title":"协方差矩阵","slug":"协方差矩阵","date":"2019-04-26T10:08:05.000Z","updated":"2019-04-26T11:05:26.014Z","comments":false,"path":"2019/04/26/协方差矩阵/","link":"","permalink":"http://yoursite.com/2019/04/26/协方差矩阵/","excerpt":"","text":"covariance matrice来自维基百科 假设X是以n个随机变量组成的列向量： 且$$mu_i = \\mathrm{E}(X_i),$$ μi是Xi的期望。 协方差矩阵的第(i,j)项被定义为如下形式。$$\\Sigma _{ij}=cov(X_i,X_j)=E[(X_i-\\mu_i)(X_j-\\mu_j)]$$ 协方差矩阵为：尽管协方差矩阵很简单，可它却是很多领域里的非常有力的工具。它能导出一个变换矩阵，这个矩阵能使数据完全去相关(decorrelation)。从不同的角度看，也就是说能够找出一组最佳的基以紧凑的方式来表达数据。(完整的证明请参考瑞利商)。 这个方法在统计学中被称为主成分分析(principal components analysis)，在图像处理中称为Karhunen-Loève 变换(KL-变换)。 协方差矩阵python实现 1234impotr numpyx = np.random.random_sample((3, 2))cov=np.cov(x)print(cov)","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"matalb","slug":"matalb","permalink":"http://yoursite.com/tags/matalb/"}]},{"title":"面向对象编程风格","slug":"面向对象编程风格","date":"2019-04-25T13:22:53.000Z","updated":"2019-04-25T14:37:21.078Z","comments":false,"path":"2019/04/25/面向对象编程风格/","link":"","permalink":"http://yoursite.com/2019/04/25/面向对象编程风格/","excerpt":"","text":"面向对象编程概念面向对象编程概念的两项最主要的特质是：继承(inheritance)和多态(polymorphism)。前者是使得我们将一群相关的类组织起来，并且让我们得以分享其间的共通数据和操作行为，后者让我们在这些类之上进行编程时，如同操纵单一个体，而非相互独立的类，并赋予我们更多弹性来加入或者移除任何特定类。 在C++中，父类被称为基类(base class)，子类被称为派生类(derived class)父类和子类之间的关系称为继承体系(inheritance hierarchy)。 我们给出一个图书馆借阅管理系统的中用到的各种馆藏的类体系。这一继承体系中最根本的类是一个抽象基类：LibMat，LibMat用来定义图书馆借阅管理系统中所有馆藏的共通操作行为。包括check_in(),check_out(),due_date(),find(),location()等等。LibMat并不代表图书馆借阅管理系统中的任意一个实际存在的馆藏，仅仅为了设计需要存在。但事实上这个抽象十分重要，我们称之为抽象基类(abstracr base class)","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"PSR","slug":"PSR","date":"2019-04-23T07:46:20.000Z","updated":"2019-04-23T08:05:33.639Z","comments":false,"path":"2019/04/23/PSR/","link":"","permalink":"http://yoursite.com/2019/04/23/PSR/","excerpt":"","text":"PSR matlab计算PSR(Pure Superpixle Ratio):纯净超像素率。计算方法为纯净超像素的个数除以总超像素个数。 matlab程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243%input:% S：超像素分割的结果% GT：groundtruth图像 图像元素为类标 整数从1开始%output:% s_error:分类错误的像素数目占超像素总像素数目的比例% PSR：纯净超像素个数占总超像素个数的比例function [s_error,PSR] = getError(S, GT) % check image sizes [hS ,wS ,cS] = size(S); [hGT,wGT ,cGT] = size(GT); if hS~=hGT || wS~= wGT || cS~=1 || cGT~=1 fprintf(&apos;Size error in getUndersegmentationError\\n&apos;); return; end nS = double(max(S(:))); %超像素的个数 nGT = double(max(GT(:))); %GROUNDtruth的类数 % prepare intersection matrix: M(i,j) = overlapping of GT==i and S==j % prepare areas of segments of S and GT areaS = zeros(nS,1); %和超像素个数一样长的向量 areaGT = zeros(nGT,1); %类别*1 nps = zeros(nS,1); %每个超像素中的像素个数 error = zeros(nS,1); %每个超像素中分类错误的像素数目 num=0; % M = zeros(nGT, nS); for i =1:nS l=find(S==i);%第i个超像素的索引 nps(i)=length(l);%第i个超像素内像素个数 for j =1:nGT areaGT(j)=length(find(GT(l)==j)); end if(nps(i)==max(areaGT)) num = num+1; end areaS(i)=max(areaGT); error(i) = nps(i)-areaS(i); end s_error=sum(error,&apos;all&apos;)/sum(nps,&apos;all&apos;); PSR = num/nS;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"superpixel","slug":"superpixel","permalink":"http://yoursite.com/tags/superpixel/"}]},{"title":"phash","slug":"phash","date":"2019-04-23T07:43:45.000Z","updated":"2019-04-23T08:05:53.338Z","comments":false,"path":"2019/04/23/phash/","link":"","permalink":"http://yoursite.com/2019/04/23/phash/","excerpt":"","text":"phash算法工作过程和代码pHash的工作过程如下： （1）缩小尺寸：pHash以小图片开始，但图片大于8 8，32 32是最好的。这样做的目的是简化了DCT的计算，而不是减小频率。 （2）简化色彩：将图片转化成灰度图像，进一步简化计算量。 （3）计算DCT：计算图片的DCT变换，得到32 * 32的DCT系数矩阵。 （4）缩小DCT：虽然DCT的结果是32 32大小的矩阵，但我们只要保留左上角的8 8的矩阵，这部分呈现了图片中的最低频率。 （5）计算平均值：如同均值哈希一样，计算DCT的均值。 （6）计算hash值：这是最主要的一步，根据8 * 8的DCT矩阵，设置0或1的64位的hash值，大于等于DCT均值的设为”1”，小于DCT均值的设为“0”。组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。 代码地址：https://github.com/JohannesBuchner/imagehash 代码示例 123456789import imagebashfrom PIL import Imagehash=imagehash.phash(Image.open('world1.png'))# hash=imagehash.average_hash(Image.open('world1.png')) #均值hash# hash=imagehash.dhash(Image.open('world1.png')) #dhash# hash=imagehash.whash(Image.open('world1.png')) #whashotherhash=imagehash.phash(Image.open('world2.png'))print(hash-otherhash)out: 15","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Phash","slug":"Phash","permalink":"http://yoursite.com/tags/Phash/"}]},{"title":"python的类成员方法","slug":"python的类成员方法","date":"2019-04-20T12:08:13.000Z","updated":"2019-04-20T12:54:04.035Z","comments":false,"path":"2019/04/20/python的类成员方法/","link":"","permalink":"http://yoursite.com/2019/04/20/python的类成员方法/","excerpt":"原作者：haozlee来源：CSDN原文题目：Python 实例方法、类方法和静态方法链接：https://blog.csdn.net/lihao21/article/details/79762681版权声明：本文为博主原创文章，转载请附上博文链接！","text":"原作者：haozlee来源：CSDN原文题目：Python 实例方法、类方法和静态方法链接：https://blog.csdn.net/lihao21/article/details/79762681版权声明：本文为博主原创文章，转载请附上博文链接！Python 的类成员方法分为实例方法，类方法和静态方法。 实例方法实例方法用得最多，也最常见。1234567891011121314151617class Kls(object): def __init__(self, data): self.data = data def printd(self): print(self.data)ik1 = Kls('leo')ik2 = Kls('lee')ik1.printd()ik2.printd()输出：leo lee 上述例子中，printd为一个实例方法。实例方法第一个参数为self，当使用ik1.printd()调用实例方法时，实例ik1会传递给self参数，这样self参数就可以引用当前正在调用实例方法的实例。利用实例方法的这个特性，上述代码正确输出了两个实例的成员数据 类方法类方法采用装饰器@classmethod来定义。1234567891011121314151617181920class Kls(object): num_inst = 0 def __init__(self): Kls.num_inst = Kls.num_inst + 1 @classmethod def get_no_of_instance(cls): return cls.num_instik1 = Kls()ik2 = Kls()print ik1.get_no_of_instance()print Kls.get_no_of_instance()输出为：22 上述例子中，我们需要统计类Kls实例的个数，因此定义了一个类变量num_inst来存放实例个数。通过装饰器@classmethod的使用，方法get_no_of_instance被定义成一个类方法。在调用类方法时，Python 会将类（class Kls）传递给cls，这样在get_no_of_instance内部就可以引用类变量num_inst。由于在调用类方法时，只需要将类型本身传递给类方法，因此，既可以通过类也可以通过实例来调用类方法。 静态方法在开发中，我们常常需要定义一些方法，这些方法跟类有关，但在实现时并不需要引用类或者实例，例如，设置环境变量，修改另一个类的变量，等。这个时候，我们可以使用静态方法。Python 使用装饰器@staticmethod来定义一个静态方法。123456789101112131415161718192021222324252627IND = 'ON'class Kls(object): def __init__(self, data): self.data = data @staticmethod def checkind(): return IND == 'ON' def do_reset(self): if self.checkind(): print('Reset done for: %s' % self.data) def set_db(self): if self.checkind(): print('DB connection made for: %s' % self.data)ik1 = Kls(24)ik1.do_reset()ik1.set_db()输出为：Reset done for: 24 DB connection made for: 24 在代码中，我们定义了一个全局变量IND，由于IND跟类Kls相关，所以我们将方法checkind放置在类Kls中定义。方法checkind只需检查IND的值，而不需要引用类或者实例，因此，我们将方法checkind定义为静态方法。对于静态方法，Python 并不需要传递类或者实例，因此，既可以使用类也可以使用实例来调用静态方法。 实例方法，类方法与静态方法的区别123456789101112131415161718192021222324252627282930313233343536373839404142class Kls(object): def foo(self, x): print('executing foo(%s,%s)' % (self, x)) @classmethod # Python 使用装饰器@staticmethod来定义一个类方法。 def class_foo(cls,x): print('executing class_foo(%s,%s)' % (cls,x)) @staticmethod # Python 使用装饰器@staticmethod来定义一个静态方法。 def static_foo(x): print('executing static_foo(%s)' % x)ik = Kls()# 实例方法ik.foo(1)print(ik.foo)print('==========================================')# 类方法ik.class_foo(1)Kls.class_foo(1)print(ik.class_foo)print('==========================================')# 静态方法ik.static_foo(1)Kls.static_foo('hi')print(ik.static_foo)输出为：executing foo(&lt;__main__.Kls object at 0x0551E190&gt;,1)&lt;bound method Kls.foo of &lt;__main__.Kls object at 0x0551E190&gt;&gt;==========================================executing class_foo(&lt;class '__main__.Kls'&gt;,1)executing class_foo(&lt;class '__main__.Kls'&gt;,1)&lt;bound method type.class_foo of &lt;class '__main__.Kls'&gt;&gt;==========================================executing static_foo(1)executing static_foo(hi)&lt;function static_foo at 0x055238B0&gt; 对于实例方法，调用时会把实例ik作为第一个参数传递给self参数。因此，调用ik.foo(1)时输出了实例ik的地址。 对于类方法，调用时会把类Kls作为第一个参数传递给cls参数。因此，调用ik.class_foo(1)时输出了Kls类型信息。前面提到，可以通过类也可以通过实例来调用类方法，在上述代码中，我们再一次进行了验证。 对于静态方法，调用时并不需要传递类或者实例。其实，静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"dhash","slug":"感知哈希算法","date":"2019-04-20T12:07:44.000Z","updated":"2019-04-23T07:44:26.723Z","comments":false,"path":"2019/04/20/感知哈希算法/","link":"","permalink":"http://yoursite.com/2019/04/20/感知哈希算法/","excerpt":"来源：简书 原作者：AmazingBillions链接：https://www.jianshu.com/p/193f0089b7a2","text":"来源：简书 原作者：AmazingBillions链接：https://www.jianshu.com/p/193f0089b7a2感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个“指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。达到图片比较目的且利用信息指纹比较。 感知哈希算法目前有： aHash：平均值哈希，速度快，但准确率较低。pHash：感知哈希，准确率高，但速度较慢。dHash：差异值哈希，速度快，且准确率高。 差异哈希算法（dHash）step1. 缩放图片如果我们要计算上图的dHash值，第一步是把它缩放到足够小。如果我们要计算上图的dHash值，第一步是把它缩放到足够小。为什么需要缩放呢？因为原图的分辨率一般都非常高。一张 200200 的图片，就有整整4万个像素点，每一个像素点都保存着一个RGB值，4万个RGB，是相当庞大的信息量，非常多的细节需要处理。因此，我们需要把图片缩放到非常小，隐藏它的细节部分，只见森林，不见树木。建议缩放为98，虽然可以缩放为任意大小，但是这个值是相对合理的。而且宽度为9，有利于我们转换为hash值。Step2. 灰度化dHash全名为差异值hash，通过计算相邻像素之间的颜色强度差异得出。我们缩放后的图片，细节已经被隐藏，信息量已经变少。但是还不够，因为它是彩色的，由RGB值组成。白色表示为（255,255,255）,黑色表示为（0,0,0），值越大颜色越亮，越小则越暗。每种颜色都由3个数值组成，也就是红、绿、蓝的值 。如果直接使用RGB值对比颜色强度差异，相当复杂，因此我们转化为灰度值——只由一个0到255的整数表示灰度。这样的话就将三维的比较简化为了一维比较。Step3. 差异计算差异值是通过计算每行相邻像素的强度对比得出的。我们的图片为9*8的分辨率，那么就有8行，每行9个像素。差异值是每行分别计算的，也就是第二行的第一个像素不会与第一行的任何像素比较。 如果前一个像素的颜色强度大于第二个像素，那么差异值就设置为True（也就是1），如果不大于第二个像素，就设置为False（也就是0）。 Step4. 转换为hash值我们将差异值数组中每一个值看做一个bit，每8个bit组成为一个16进制值，将16进制值连接起来转换为字符串，就得出了最后的dHash值。 Step5.计算汉明距离汉明距离这个概念不止运用于图片对比领域，也被使用于众多领域，具体的介绍可以参见Wikipedia。汉明距离表示将A修改成为B，需要多少个步骤。比如字符串“abc”与“ab3”，汉明距离为1，因为只需要修改“c”为“3”即可。dHash中的汉明距离是通过计算差异值的修改位数。我们的差异值是用0、1表示的，可以看做二进制。二进制0110与1111的汉明距离为2。我们将两张图片的dHash值转换为二进制difference，并取异或。计算异或结果的“1”的位数，也就是不相同的位数，这就是汉明距离 如果传入的参数不是两张图的dHash值，而是直接比较两张图片，那么不需要生成dHash值，直接用Step3中的difference数组，统计不相同的位数，就是汉明距离。一般来说，汉明距离小于5，基本就是同一张图片。大家可以根据自己的实际情况，判断汉明距离临界值为多少。 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class DHash(object): @staticmethod def calculate_hash(image): \"\"\" 计算图片的dHash值 :param image: PIL.Image :return: dHash值,string类型 \"\"\" difference = DHash.__difference(image) # 转化为16进制(每个差值为一个bit,每8bit转为一个16进制) decimal_value = 0 hash_string = \"\" for index, value in enumerate(difference): if value: # value为0, 不用计算, 程序优化 decimal_value += value * (2 ** (index % 8)) if index % 8 == 7: # 每8位的结束 hash_string += str(hex(decimal_value)[2:].rjust(2, \"0\")) # 不足2位以0填充。0xf=&gt;0x0f decimal_value = 0 return hash_string @staticmethod def hamming_distance(first, second): \"\"\" 计算两张图片的汉明距离(基于dHash算法) :param first: Image或者dHash值(str) :param second: Image或者dHash值(str) :return: hamming distance. 值越大,说明两张图片差别越大,反之,则说明越相似 \"\"\" # A. dHash值计算汉明距离 if isinstance(first, str): return DHash.__hamming_distance_with_hash(first, second) # B. image计算汉明距离 hamming_distance = 0 image1_difference = DHash.__difference(first) image2_difference = DHash.__difference(second) for index, img1_pix in enumerate(image1_difference): img2_pix = image2_difference[index] if img1_pix != img2_pix: hamming_distance += 1 return hamming_distance @staticmethod def __difference(image): \"\"\" *Private method* 计算image的像素差值 :param image: PIL.Image :return: 差值数组。0、1组成 \"\"\" resize_width = 9 resize_height = 8 # 1. resize to (9,8) smaller_image = image.resize((resize_width, resize_height)) # 2. 灰度化 Grayscale grayscale_image = smaller_image.convert(\"L\") # 3. 比较相邻像素 pixels = list(grayscale_image.getdata()) difference = [] for row in range(resize_height): row_start_index = row * resize_width for col in range(resize_width - 1): left_pixel_index = row_start_index + col difference.append(pixels[left_pixel_index] &gt; pixels[left_pixel_index + 1]) return difference @staticmethod def __hamming_distance_with_hash(dhash1, dhash2): \"\"\" *Private method* 根据dHash值计算hamming distance :param dhash1: str :param dhash2: str :return: 汉明距离(int) \"\"\" difference = (int(dhash1, 16)) ^ (int(dhash2, 16)) return bin(difference).count(\"1\")","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"dhash","slug":"dhash","permalink":"http://yoursite.com/tags/dhash/"}]},{"title":"基于对象的编程风格","slug":"基于对象的编程风格","date":"2019-04-19T08:25:20.000Z","updated":"2019-04-23T08:47:29.953Z","comments":false,"path":"2019/04/19/基于对象的编程风格/","link":"","permalink":"http://yoursite.com/2019/04/19/基于对象的编程风格/","excerpt":"","text":"class 名称被视为一个类型(type)名称，如同int ,double一样。Class object的初始化做法有很多种。每个class都会提供一组操作函数，可以作用于其object上。这些操作函数包括具名函数，如size(),empty()，以及各种重载的运算符，如equality和assignment运算符。 实现一个Class12345678910111213class Stack&#123;public: bool push(const string&amp;); bool pop(string &amp;elem); bool peek(string &amp;elem); bool empty(); bool full(); int size()&#123;return _stack.size();&#125;private: vector&lt;string&gt; _stack;# 编程习惯，在data member之前加下划线_&#125;; 上面为class的声名。Public member可以在成员的任何地方被访问，而private member只能在member fuction或class friend内被访问。所有的member fuction都必须在class主体内进行声明，若在主体内定义则会被视为inline函数。在class主体外定义inline函数要在最前面指定关键字inline。 class member fuction定义为了分辨该函数属于哪一个class，在class主体外定义member fuction要在函数名前加类名和两个冒号，例如:123456789101112131415inline boolStack::empty()&#123; return _stack.empty();&#125;boolStack::pop(string &amp;elem)&#123; if(empty()) return false; elem=_stack.back(); _stack.pop_back(); return true;&#125; 构造函数(constructor)和析构函数(destructor)1234567891011121314151617181920212223242526class Triangular&#123;public: //一组重载的constructor Triangular(); //default constructors Triangular(int len); Triangular(int len,int beg_pos);private: ......&#125;;//构造函数的实现Triangular::Triangular()&#123; _length = 1; _beg_pos = 1; _next =0;&#125;Triangular::Triangular(int len,int bp)&#123; //_legth和_beg_pos必须&gt;=1 //最好不要相信‘用户永远是对的’这句话 _length = len&gt;0? len : 1; _beg_pos = bp&gt;0? bp : 1; _next =_beg_pos-1;&#125; 成员初始化列表Member initialization list主要用于将参数传给member class object的constructor。 定义一个包含string member的Triangular类 1234567891011121314151617class Triangular&#123;public: //...private: string _name; int _next, _length, _beg_pos;&#125;;//为了将_name的值传给string constructor，必须使用member initialization list完成初始化。Triangular::Triangular(int len,int bp) ：_name(\"Triangular\")&#123; _length = len&gt;0? len : 1; _beg_pos = bp&gt;0? bp : 1; _next =_beg_pos-1;&#125; deconstructordestructor的名称有严格规定：class名称加~前缀，没有返回值也没有任何参数。不可能被重载。 1234567891011121314class Matrix&#123;public: Matrix(int row, int col) :_row(row),_col(col) &#123; _pmat = new double[row*col] ;//注意此处未检查成功与否 &#125; ~Matrix() &#123; //进行资源的释放 delete[] _pmat; &#125;&#125;; 成员逐一初始化 默认情况下，当用某个class object来作为另一个object的初值时，default memberwise initialization会一次复制class data member。 在Triangular类中使用默认的成员逐一初始化会正确复制所有的data member，但是对Matrix类使用默认的成员逐一初始化则并不适当。 12345678Matrix mat(4,4);//constructor发生作用Matrix mat2 = mat ; //进行default memberwise initialization//在这里使用mat2//在这里mat2的destructor起作用// 在这里使用mat//mat的destructor起作用 default memberwise initialization将mat2的_pmat设置为mat的_pmat的值：1mat2._pmat = mat._pmat; 当mat2的destructor作用后，该空间便被释放，但是mat的_pmat仍指向该数组，这是非常严重的错误行为。 正确的方法是为其设计合适的copy constructor 123456789Matrix::Matrix(const Matrix &amp;rhs) :_row(rhs._row),_col(rhs._col) &#123; //对rhs._pmat所指的数组产生一份完全的复本 int elem_cnt = _row*_col; _pmat = new double(elem_cnt); for(int ix=0;ix&lt;elem_cnt;++ix) _pmat[ix]=rhs._pmat[ix]; &#125; mutable(可变)和const(不变)1int sum(const Triangular &amp;train) train为 const reference参数 编译器必须保证train在sum中不会被修改。为此class设计者必须在member fuction身上标注const来告诉编译器：此member function不会更改class object内容。 1234567891011121314151617class Triangular&#123;public: //const member function int length() const&#123;return _length&#125;; int beg_pos() const&#123;return _beg_pos&#125;; int elem(int pos) const; //non-const member function bool next(int &amp;val); void next_reset()&#123;_next=beg_pos-1&#125;;private: int _length; int _beg_pos; mutable int _next; //static data member static vector&lt;int&gt; _elems;&#125;; 上述程序将_next标示为mutable，表示改变_next的值，不能视为改变class object的状态，或者是不算是改变了class object的常量性(constness)。若一个函数改变了Triangular object的_next值，其仍然可以被标示为const，而不会报错。 this指针this指针在member function中用来指向其调用者(一个对象)。1234567891011Triangular&amp; Triangular::copy(const Triangular &amp;rhs)&#123; if(this != &amp;rhs) &#123; _length=rhs._length; _beg_pos=rhs._beg_pos; _next=_rhs._beg_pos-1; &#125; return *this;&#125; 静态类成员static data member用来表示唯一的 可共享的member。它可以在同一类的所有对象中被访问。对class 来说，static data member只有唯一的一份实体。因此我们必须在程序代码中提供其清楚的定义。1vector&lt;int&gt; Triangular::_elems; static member fuction(静态成员函数在成员函数前面加上static，可以让该函数在与任何对象都无瓜葛的情形下被调用。例如:12if(Triangular::is_elem(8)) ..... 运算符重载(打造一个Iterator Class)为了说明如何对class进行运算符重载操作，我们来实现一个iterator class。我们需要提供以下操作方式。 123456789Triangular train(1,8);Triangular::iterator it = train.begin(); end_it=train.end();while(it!=end_it)&#123; cout&lt;&lt;*it&lt;&lt;' '; ++it;&#125; 实现Triangular_iterator类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Triangular_iterator&#123;public://为了不在每次访问元素都执行index-1操作，此处将_index的值设置为index-1 Triangular_iterator(int index):_index(index-1)&#123;&#125; bool operator==(const Triangular_iterator&amp;) const; bool operator!=(const Triangular_iterator&amp;) const; int operator*() const; Triangular_iterator&amp; operator++(); #++前置 Triangular_iterator operator++(int);#后置++private: void check_integrity() const; int _index;&#125;; inline bool Triangular_iterator :: operator==(const Triangular_iterator&amp; rhs) const &#123;return _index == rhs._index;&#125; #如果两个对象的_index相等，我们认为这两个对象相等 inline bool Triangular_iterator :: operator==(const Triangular_iterator&amp; rhs) const &#123;return！(*this== rhs);&#125;# 任何运算符如果和另一个运算符性质相反我们通常用后者来实现前者。 inline int Triangular_iterator :: operator*(const Triangular_iterator&amp; rhs) const &#123; check_integrity(); return Triangular::_elems[_index] &#125; inline void Triangular_iterator :: check_integrity() const &#123; if(_index&gt;=Triangular::_max_elems) throw iterator_overflow(); if(_index&gt;=Triangular::_elems.size()) Triangular::gen_elements(_index+1); &#125; inline Triangular_iterator&amp; Triangular_iterator :: operator++() &#123; //前置版本 ++_index; check_integrity(); return *this; &#125; inline Triangular_iterator&amp; Triangular_iterator :: operator++(int)//后置版本的参数列表本应是空的，但根据重载要求，参数列表必须独一无二，因此c++要求后置版本要有一个int参数 &#123; //后置版本 Triangular_interator tmp = *this; ++_index; check_integrity(); return tmp; &#125; 接下来对Triangular类进行修正12345678910111213141516171819202122#include \"Triangular_iterator.h\"class Triangular&#123;public: typedef Triangular_iterator iterator; Triangular_iterator begin()const &#123; return Triangular_iterator(_beg_pos); &#125; Triangular_iterator end)const &#123; return Triangular_iterator(_beg_pos+_length); &#125; //..... 人物志：胡歌-总有那么几个人，优秀到让你窒息。private: int _beg_pos; int _length; //...&#125;; 友元以下的non-member operator*可以直接访问Triangular的private _elems以及Triangular_iterator的pravate check_integrity(): 12345inlint int operator*(const Triangular_iterator &amp;rhs)&#123; rhs.check_integrity(); return Triangular::_elems[rhs.index()];&#125; 任何class都可以将其他fuction或者class制定为firend，这样这些class和function就有了与class member相同的访问权限，可以访问类的private member。为了让operator*()通过编译 我们需要将其设置为Triangular和Triangular_iterator的friend。12345678class Triangular&#123; friend int operator*(const Triangular_iterator &amp;rhs); //... &#125;; class Triangular_iterator&#123; friend int operator*(const Triangular_iterator &amp;rhs); //... &#125;; Triangular_iterator内的operator*()和check_integrity()都需要直接访问Triangular的private member因此我们将两者都声名为Triangular的friend。 12345class Triangular&#123; friend int Triangular_iterator::operator*(); friend int Triangular_iterator::cheack_integrity(); //... &#125;; 为了成功通过编译 我们必须在上述代码之前先提供Triangular_iterator的定义让T知道。我们也可以令class A 和class B建立firend关系。借此是的class A的所有member fuction都成为class B 的friend。1234class Triangular&#123; friend class Triangular_iterator; //... &#125;; 友谊的建立通常是为了效率考虑，如果我们只是希望进行某个data member的读取和写入，那么为它提供具有Public访问权限的inline函数，也是建立友谊之外的一个替代方案。 function object一种提供有fuction call运算符的class。当编译器在编译过程中遇到函数调用，如1lt(ival); lt可能是函数名称，可能是函数指针，也可能是一个提供了function call运算符的function object。如果lt是一个class object。编译器会在内部将此语句转化为1lt.operator(ival); function call运算符可以接受任意个数的参数。下面来实现一个function call运算符，测试传入的值是否小于某指定值。123456789101112131415161718192021222324252627282930class LessThan&#123;public: LessThan(int val):_val(val)&#123;&#125; int comp_val()const &#123;return _val;&#125;//读取基值 void comp_val(int nval)&#123;_val=nval;&#125;//基值的写入 bool operator()(int _value)const;private: int _val;&#125;;//fuction call 运算符的实现inline bool LessThan::operator()(int value) const &#123;return value&lt;_val;&#125;//function call 运算符应用到对象身上，便可调用function call运算符int count_less_than(const vector&lt;int&gt; &amp;vec,int comp)&#123; LessThan lt(comp); //定义一个对象并且初始化 int count = 0; for(int ix=0;ix&lt;vec.size();++ix) &#123; if(lt(vec[ix])) ++count; return count; &#125;&#125; 重载iostream运算符我们常常会用到对某个class object进行读取和写入操作。如果我们想要显示train对象的内容，我们可能会希望这样写：输出运算符重载1cout&lt;&lt;train&lt;&lt;end; 为了支持这种形式，我们需要提供一份重载的output运算符:1234567891011ostream &amp; operator&lt;&lt;(ostream &amp;os,const Triangular &amp;rhs)&#123; os&lt;&lt;\"(\"&lt;&lt;rhs.beg_pos()&lt;&lt;\",\" &lt;&lt;rhs.length()&lt;&lt;\")\"; rhs.display(rhs.length(),rhs.beg_pos(),os); return os;&#125;Triangular tri(6,3);cout&lt;&lt;tri&lt;&lt;'\\n';out:(3,6) 6 10 15 21 28 36 为什么不把output设计为一个member function呢？因为作为一个member function，其左操作数必须为隶属于同一个class的对象。也就是说object必须放在output操作符的左侧：1tri&lt;&lt;count&lt;&lt;'\\n'; 这会给class用户带来困惑。输入运算符重载以下input运算符只读取与Tiangular有关的前四个部分,所有Triangular对象之间的差别只在于长度和起始位置。1234567891011121314151617181920212223242526272829303132333435istream&amp;operator&gt;&gt;(istream &amp;is,Triangular &amp;rhs)&#123; char ch1,ch2; int bp,len; //假设输入为(3,6) 6 10 15 21 28 36 //那么ch1='(',bp=3,ch2=',',len=6 is&gt;&gt;ch1&gt;&gt;bp &gt;&gt;ch2&gt;&gt;len; //设定rhs的三个data member rhs.beg_pos(bp); rhs.length(len); rhs.next_reset(); return is;&#125;// 测试程序void main()&#123; Triangular tri(6,3); cout&lt;&lt;tri&lt;&lt;'\\n'; Triangular tri2; cin&gt;&gt;tri2; //让我们看看我们拿到了什么 cout&lt;&lt;tri2; out: (3,6) 6 10 15 21 28 36in: (4,10)out: (4,10) 10 15 21 28 36 45 55 66 78 91&#125; 指针 指向Class Member Fuction","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"环境变量","slug":"环境变量","date":"2019-04-19T04:46:05.000Z","updated":"2019-04-19T07:10:13.342Z","comments":false,"path":"2019/04/19/环境变量/","link":"","permalink":"http://yoursite.com/2019/04/19/环境变量/","excerpt":"","text":"全局变量和局部变量bash shell用环境变量的特性来存储有关shell会话和工作环境的信息。在bash shell中，环境变量分为两类： 全局变量 局部变量 linxu系统在开始bash会话时就设置了一些全局环境变量。123456789env #查看所有全局变量printenv #查看所有全局变量$ printenv HOME # printenv命令也可以用来查看某个全局变量/home/mike$ echo $HOME #echo 命令不仅显示某个局部变量的值 同时让变量作为命令行参数/home/mikeset #set命令显示为某个特定进程设置的所有环境变量 包括局部变量 全局变量 以及用户自定义变量 用户自定义变量123456$ my_variable='Hello world'#变量名 等号 值之间不能有空格 值为含有空格的字符串 要用单引号括起来$ echo my_variableHello worle$ export my_variable #将局部变量导出到全局环境中unset my_variable #删除环境变量 子shell无法使用父shell中设置的用户自定义变量，在子shell中设置了局部变量，一旦退出子shell 这个局部变量便不可用。 在设定全局环境变量的进程所创建的子进程中，该变量均为可见的。修改或者删除子shell中的全局环境变量的值并不会影响到父shell中该变量的值。子shell无法使用export命令改变父shell中全局环境变量的值。 PATH环境变量设置当在shell命令行中输入一个外部命令时，shell必须搜索系统来找到对应的程序。PATH环境变量定义了用于进行命令和程序查找的目录 12$ echo $PATH #PATH中的目录间用冒号分隔/home/mike/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin 问题是应用程序放置可执行文件的目录常常不在PATH所包含的目录中。解决方法是保证PATH中包含了所有存放应用程序的目录。可以把新的搜索目录添加到现有的PATH目录中。无需从头定义。只需要引用原来的值，再给这个字符串添加新目录就可以了。1234567$ echo $PATH/home/mike/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin$$ PATH=$PATH:/home/mike/Scripts$$ echo $PATH/home/mike/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/mike/Scripts 通常的办法是将单点符加入PATH环境变量中，单点符代表当前目录。1PATH=$PATH:. 对PATH变量的修改只能持续到推出或者重启系统，并不能一直持续 系统环境变量当登陆linux系统时，bash shell会作为登陆shell启动，登陆shell会从5个不同的启动文件中读取命令： /ect/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile /ect/profile文件是系统默认的bash shell的主启动文件，每个用户登陆时都会执行这个启动文件。另外四个是启动文件是针对用户的。大多数linux发行版只用到其中的一两个。shell会按照下列顺序运行第一个被找到的文件，其他的被忽略： $HOME/.bash_profile $HOME/.bash_login $HOME/.profile这个列表中并没有- $HOME/.bashrc，因为该文件同从是通过其他文件启动的。 交互式shell(比如是在命令行提示符下敲入bash时启动)，只会检查 $HOME/.bashrc 文件非交互式shell(系统执行shell脚本时用的shell) bash shell 提供了BASH_ENV环境变量来为其提供查看启动文件的路径。若该变量没有被设置，由于子shell可以继承父shell导出的环境变量。如果父shell是登陆shell,则执行该脚本的子shell就可以继承登陆shell设置过并导出的变量。","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"系统管理命令","slug":"系统管理命令","date":"2019-04-18T12:22:49.000Z","updated":"2019-04-18T13:33:23.036Z","comments":false,"path":"2019/04/18/系统管理命令/","link":"","permalink":"http://yoursite.com/2019/04/18/系统管理命令/","excerpt":"","text":"监测进程1234ps -ef # 查看系统允许的所有进程top # 实时显示进程信息 按q退出kill UID #杀死指定进程号的进程 你必须为此进程的属主或root用户killall #结束所有进程 监测磁盘空间12345678mount -t type device directory #手动挂载媒体设备的基本命令mount -t vfat /dev/sdb1 /media/disk #手动将u盘/dev/sdb1挂载到/media/diskumount [directory|device] #卸载设备 只能在设备没有被占用的时候卸载umount /home/rich/mnt #卸载mnt设备df -h # 显示某个设备上还有多少磁盘空间du -ch #显示某个特定目录的磁盘使用情况 默认为当前目录du -s #显示某个特定目录的每个输出参数的总计 排序数据12sort -n file #将数字识别为数字 并按值排序sort -M file #将含有时间戳日期的文件按月份排序 搜索数据123456grep [options] pattern [file] #grep 命令行格式$ grep three filethree$ grep t file1twothree 压缩数据12345$ gzip my*$ ls -l my*-rwxrwxr-x 1 rich rich 2197 2007-09-13 11:29 myprog.gz-rwxrwxr-x 1 rich rich 5178 2007-09-13 11:29 myscript.gz-rwxrwxr-x 1 rich rich 60 2007-09-13 11:29 myscript2.gz 归档数据123tar -cvf test.tar test/ test2/ #创建名为test.tar的归档文件 含有test 和test2目录内容tar -tf test.tar #查看tar文件test.tar中的内容tar -xvf # 从tar文件中提取内容 在当前目录下重建","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"引用和指针的区别","slug":"引用和指针的区别","date":"2019-04-18T11:12:45.000Z","updated":"2019-04-18T11:40:43.144Z","comments":false,"path":"2019/04/18/引用和指针的区别/","link":"","permalink":"http://yoursite.com/2019/04/18/引用和指针的区别/","excerpt":"","text":"123int ival =1024; //初始化 int类型数据int *pi = &amp;ival; // pointer初始化 pi指向一个int对象int &amp;rval = ival; //reference 引用 代表一个int对象 通过by reference将对象作为函数参数传入时，函数可直接对传入的对象进行修改，也可以降低复制大型对象的负担。 也可以将对象以pointer的形式传递给函数，这与reference效果相同：传递的都是对象的地址，而不是整个对象的副本。两者区别为用法不同。 point参数和reference参赛之间更重要的差异是： pointer可能（也可能不）指向某个实际对象，当我们提领pointer时，一定要确定其值非0，而reference则必定会指向某个对象（不为null），所以不必作此检查 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化） 一旦引用被初始化，就不能改变引用的关系，即不能再指向其他对象（指针则可以随时改变所指的对象）","categories":[{"name":"program lauguage","slug":"program-lauguage","permalink":"http://yoursite.com/categories/program-lauguage/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"文件系统操作","slug":"文件系统操作","date":"2019-04-18T08:39:22.000Z","updated":"2019-04-18T10:08:46.984Z","comments":false,"path":"2019/04/18/文件系统操作/","link":"","permalink":"http://yoursite.com/2019/04/18/文件系统操作/","excerpt":"","text":"遍历目录1cd destiantion #cd 加目录名 可切换到目标目录 change dictionary destiantion可用相对目录和绝对目录来表示绝对目录路径以正斜线/开始，正斜线表示根目录，也可以～开始 表示家目录相对路径为基于当前位置的目标文件路径 单点符.表示当前目录 双点符表示当前目录的父目录。1pwd #print work dictionary 显示当前目录 基本列表功能12345ls #list 显示当前目录下的文件和目录ls -F # -F参数在目录名后加了正斜线/ 便于区分文件和目录ls -a # 显示所有文件 包括隐藏文件ls -R #列出当前目录下包含的子目录中的文件ls -l #显示长列表 每一行都包括一个文件的许多信息 处理文件123touch test #创建一个空的文件cp source destination # copy复制文件mv source destination #move 用来重命名或者移动文件 文件夹 处理目录12345mkdir 目录名 #新建一个目录mkdir -p #同时创建多个目录和子目录rmdir 目录名 #删除目录 默认只删除空目录rm -ir #删除目录及其所有内容tree #以树状图的形式显示目录子目录及其中的文件 需要手动安装 查看文件内容1234file my_file #查看文件类型cat test1 # 查看整个文件内容tail -n text #显示文件的最后n行head -n text #显示文件的前n行","categories":[{"name":"computer system","slug":"computer-system","permalink":"http://yoursite.com/categories/computer-system/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"hexo基本操作","slug":"hexo-baseic","date":"2019-04-17T04:36:48.000Z","updated":"2019-04-18T11:42:49.352Z","comments":false,"path":"2019/04/17/hexo-baseic/","link":"","permalink":"http://yoursite.com/2019/04/17/hexo-baseic/","excerpt":"","text":"hexo cleanhexo ghexo shexo dhexo new “”星期三, 17. 四月 2019 11:13下午","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"-hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"frist blog","slug":"frist-blog","date":"2019-04-17T04:36:48.000Z","updated":"2019-04-18T09:17:04.364Z","comments":false,"path":"2019/04/17/frist-blog/","link":"","permalink":"http://yoursite.com/2019/04/17/frist-blog/","excerpt":"","text":"星期三, 17. 四月 2019 12:40下午my fist blog mike","categories":[{"name":"diary","slug":"diary","permalink":"http://yoursite.com/categories/diary/"}],"tags":[{"name":"-炮姐 -动漫","slug":"炮姐-动漫","permalink":"http://yoursite.com/tags/炮姐-动漫/"}]}]}